<?xml version="1.0" encoding="UTF-8"?>
<!-- Â© TEI Consortium. Dual-licensed under CC-by and BSD2 licenses; see the file COPYING.txt for details. -->
<?xml-model href="https://jenkins.tei-c.org/job/TEIP5-dev/lastSuccessfulBuild/artifact/P5/release/xml/tei/odd/p5.nvdl" type="application/xml" schematypens="http://purl.oclc.org/dsdl/nvdl/ns/structure/1.0"?>
<div xmlns="http://www.tei-c.org/ns/1.0" type="div1" xml:id="USE">
  <head>Using the TEI</head>


  <p>This section discusses some technical topics concerning the deployment of the TEI markup schema
    documented elsewhere in these Guidelines.
    <!-- The TEI scheme is intended both to support best
current practice and to facilitate enhancement and customization of
that practice. -->
    In section <ptr target="#MD"/> we discuss the scope and variety of the TEI customization
    mechanisms<!--, distinguishing between <soCalled>clean</soCalled> modifications, which result in a
    schema that supports a subset of the distinctions made in the full TEI system, on the one hand,
    from <soCalled>unclean</soCalled> modifications, which result in a schema that does not have
    this property-->.
    In <ptr target="#CF"/> we define the notions of <term>TEI Conformance</term> and
      <!-- distinguishing between documents which are algorithmically TEI-conformant ("TEI-conformable")
    from those which are intrinsically conformant ("TEI-conformant"); we also define the concept of
    a --><term>TEI
      Extension</term>. Since the ODD markup description language defined in chapter <ptr
      target="#TD"/> is fundamental to the way conformance and customization are handled in the TEI
    system, these two definitional sections are followed by a section (<ptr target="#IM"/>) which
    describes the intended behaviour of an ODD processor. </p>

  <!-- Section added 2012-10-09 by MDH per http://purl.org/tei/fr/3565152. -->
  <!--   ... needs to go somewhere else. but i dont know where. LB 2016-11-26 -->
  <div type="div2" xml:id="MEDIATYPE">
    <head>Serving TEI files with the TEI Media Type</head>
    <p>In February 2011, the media type <code>application/tei+xml</code> was registered with IANA
      for <q>markup languages defined in accordance with the Text Encoding and Interchange
        guidelines</q> (<ref target="https://www.rfc-editor.org/info/rfc6129">RFC 6129</ref>). We
      recommend that any XML file whose root element is in the TEI namespace be served with the
      media type <code>application/tei+xml</code> to enable and encourage automated recognition and
      processing of TEI files by external applications.</p>
  </div>

  <div type="div2" xml:id="DT" n="36">
    <head>Obtaining the TEI</head>
    <p>As discussed in chapter <ptr target="#TD"/>, all components of the TEI schema are generated
      from a single set of TEI XML source files. Schemas can be generated in each of XML DTD
      language, W3C schema language, and RELAX NG schema language. Documentation can be generated in
      a variety of commonly-used document formats, including HTML, DOCX, or PDF.
      <!-- In the body of these Guidelines, only the latter form is presented, using the compact syntax. 
--></p>
    <p>TEI components are freely available over the Internet and elsewhere. The canonical home for
      the TEI source, the schema fragments generated from it, and example modifications, is the TEI
      repository at <ptr target="https://github.com/TEIC/TEI"/>; versions are also available in
      other formats, along with copies of these Guidelines and related materials, from the TEI web
      site at <ptr target="http://www.tei-c.org/"/>.</p>

  </div>



  <div type="div2" xml:id="MD">

    <head>Customization</head>

    <p>These Guidelines provide an encoding schema suitable for encoding a very wide range of texts,
      and capable of supporting a wide variety of applications. For this reason, the TEI schema
      supports a variety of different approaches to solving similar problems, and also defines a
      much richer set of elements than is likely to be necessary in any given project. Furthermore,
      the TEI schema may be extended in well-defined and documented ways for texts that cannot be
      conveniently or appropriately encoded using what is provided. For these reasons, it is almost
      impossible to use the TEI schema without customizing it in some way. </p>

    <p>This section describes how the TEI encoding schema may be customized, and should be read in
      conjunction with chapter <ptr target="#TD"/>, which describes how a specific application of
      the TEI encoding schema should be documented. The documentation system described in that
      chapter is, like the rest of the TEI schema, independent of any particular schema or document
      type definition language. </p>

    <p>Formally speaking, these Guidelines provide both syntactic rules about how elements and
      attributes may be used in valid documents and semantic recommendations about what
      interpretation should be attached to a given syntactic construct. In this sense, they provide
      both a <term>document type definition</term> and a <term>document type declaration</term>.
      More exactly, we may distinguish between the <term>TEI Abstract Model</term>, which defines a
      set of related concepts, and the <term>TEI schema</term> which defines a set of syntactic
      rules and constraints. Many (though not all) of the semantic recommendations are provided
      solely as informal descriptive prose, though some of them are also enforced by means of such
      constructs as datatypes (see <ptr target="#DTYPES"/>), or by schema constraints expressed
      using the Schematron language. Schematron constraints provide information about special kinds
      of validation errors dependent on conditional relationships, such as the invalidity of an
      attribute name or value on one element when another is present, or when, given a pair of
      attributes such as <att>minOccurs</att> and <att>maxOccurs</att>, the minimum value exceeds
      the maximum value. Schematron constraints also provide warnings when a particular element,
      attribute, or combination is to be deprecated in future releases of the TEI scheme, to alert
      users that the feature in question is no longer to be used after a certain date. Very rarely,
      TEI Schematron constraints offer warnings that do not explicitly break with the TEI but
      suggest a more efficient or less ambiguous encoding.
      <!--2018-07-20 ebb: Example here: the one and only Schematron constraint with role="warning": 
      <constraintSpec xmlns:sch="http://purl.oclc.org/dsdl/schematron"
                   scheme="schematron"
                   ident="no_outputs_nor_predicates_4_my_kids">
      <constraint>
        <sch:rule context="tei:modelSequence">
         <sch:report test="tei:model[@output]" role="warning">The 'model' children
      of a 'modelSequence' element inherit the @output attribute of the
      parent 'modelSequence', and thus should not have their own</sch:report>
         </sch:rule>
      </constraint>
  </constraintSpec>
     
      -->
      Although the descriptions, validation errors, and warnings have been written with care, there
      will inevitably be cases where the intention of the contributors has not been conveyed with
      sufficient clarity to prevent users of these Guidelines from <soCalled>extending</soCalled>
      them in the sense of attaching slightly variant semantics to them. </p>

    <p>Beyond this unintentional semantic extension, some of the elements described can
      intentionally be used in a variety of ways; for example, the element <gi>note</gi> has an
      attribute <att>type</att> which can take on arbitrary string values, depending on how it is
      used in a document. A new type of <q>note</q>, therefore, requires no change in the existing
      model. On the other hand, for many applications, it may be desirable to constrain the possible
      values for the <att>type</att> attribute to a small set of possibilities. A schema modified in
      this way would no longer necessarily regard as valid the same set of documents as the
      corresponding unmodified TEI schema, but would remain faithful to the same conceptual
      model.</p>


    <p>This section explains how the TEI schema can be customized by suppressing elements, modifying
      classes of elements, or adding elements<!--, and renaming elements-->. Documents which
      validate against an application of the TEI schema which has been customized in this way may or
      may not be considered <soCalled>TEI-conformant</soCalled>, as further discussed in section
        <ptr target="#CF"/>.</p>

    <p>The TEI system is designed to support modification and customization in a documented way that
      can be validated by an XML processor. This is achieved by writing a small TEI-conformant
      document, known informally as an ODD (One Document Does it all), from which an appropriate
      processor can generate both human-readable documentation, and a schema expressed in a language
      such as RELAX NG or DTD. The mechanisms used to instantiate a TEI schema differ for different
      schema languages, and are therefore not defined here. In XML DTDs, for example, extensive use
      is made of parameter entities, while in RELAX NG schemas, extensive use is made of patterns.
      In either case, the names of elements and, wherever possible, their attributes and content
      models are defined indirectly. The syntax used to implement this indirection also varies with
      the schema language used, but the underlying constructs in the TEI Abstract Model are given
      the same names.
      <!--2018-07-20 ebb: ?? Readers may be confused about what we mean by "defined indirectly" in this paragraph, and why that's important. I suspect we can explain this a little more clearly by introducing ODD explicitly here, earlier than its first introduction in the paragraph after next. Maybe we could explain here that indirect definition should prioritize efficient, human-readable customizations of the TEI schema. -->
      This indirection makes it simpler to implement customization of the TEI system in an
      accessible and human-readable way. </p>

    <p>As further discussed in section <ptr target="#ST"/>, the TEI encoding schema comprises a set
      of class and macro declarations, and a number of <term>modules</term>. Each module is made up
      of element and attribute declarations, and a schema is made by combining a particular set of
      modules together. In the absence of any other kind of customization, when modules are combined
      together: <list rend="numbered">
        <item>all the elements defined by the module (and described in the corresponding section of
          these Guidelines) are included in the schema;</item>
        <item>each such element is identified by the canonical name given it in these
          Guidelines;</item>
        <item>the content model of each such element is as defined by these Guidelines;</item>
        <item>the names, datatypes, and permitted values declared for each attribute associated with
          each such element are as given in these Guidelines;</item>
        <item>the elements comprising element classes and the meaning of macro declarations
          expressed in terms of element classes is determined by the particular combination of
          modules selected.</item>
      </list> The TEI customization mechanisms allow the user to control this behaviour as follows:
        <list rend="numbered">
        <item>particular elements may be suppressed, removing them from any classes in which they
          are members, and also from any generated schema; </item>
        <item>new elements may be added to an existing class, thus making them available in macros
          or content models defined in terms of those classes;</item>
        <item>additional attributes, or attribute values, may be specified for an individual element
          or for classes of elements; </item>
        <item>within certain limits, attributes, or attribute values, may also be removed either
          from an individual element or for classes of elements; </item>
        <item>the characteristics inherited by one class from another class may be modified by
          modifying its class membership: all members of the class then inherit the changed
          characteristics;</item>
        <item>the set of values legal for an attribute or attribute class may be constrained or
          relaxed by supplying or modifying a value list, or by modifying its datatype.</item>
        <item>within certain limits, the name (generic identifier) associated with an element may be
          changed, without changing the semantic or syntactic properties of the element;</item>

      </list> The modification mechanisms presented in this section are quite general, and may be
      used to make all the types of changes just listed. </p>

    <p>The recommended way of implementing and documenting all such modifications is by means of the
      ODD system described in chapter <ptr target="#TD"/>; in the remainder of this section we give
      specific examples to illustrate how that system may be applied. An ODD processor, such as the
      Roma application supported by the TEI, or any other comparable set of stylesheets will use the
      declarations provided by an ODD to generate appropriate sets of declarations in a specific
      schema language such as RELAX NG or the XML DTD language. We do not discuss in detail here how
      this should be done, since the details are schema language-specific; some background
      information about the methods used for XML DTD and RELAX NG schema generation is however
      provided in section <ptr target="#STIN"/>. Several example ODD files are also provided as part
      of the standard TEI release: see further section <ptr target="#MDlite"/> below.</p>

    <div type="div3" xml:id="MDMD">
      <head>Kinds of Modification</head>
      <p>For ease of discussion, we distinguish the following different kinds of modification: <list
          rend="numbered">
          <item>deletion of elements;</item>
          <item>modification of content models;</item>
          <item>modification of attribute and attribute-value lists;</item>
          <item>modification of class membership;</item>
          <item>addition of new elements.</item>
          <item>renaming of elements;</item>
  
        </list> Each of these is described in the following sections.</p>

      <p>Each kind of modification changes the set of documents that will be considered valid
        according to the resulting schema. A schema derived from any combination of unmodified TEI
        declarations (an "unmodified schema") may be thought of as defining a certain set of
        documents. A schema deriving from a combination of modified TEI declarations (a "modified
        schema") will define a different set of documents. The set of documents valid according to
        the modified schema may or may not be properly contained by the set of documents considered
        to be valid according to the unmodified schema. The schema <ident>TEI-All</ident> is the
        special case of the unmodified schema which includes all currently available TEI modules. We
        use the term <term>clean modification</term> for cases where the set of documents defined by a
        modified schema is a proper subset of the set of documents defined by TEI-All. Where this is
        not the case, that is, where the modified schema considers valid some documents which
        TEI-All does not, we use the term <term>unclean modification</term>. Despite this
        terminology, unclean modifications are not particularly deprecated, and their use may often
        be vital to the success of a project. The concept is introduced solely to distinguish the
        effects of different kinds of modification.</p>

      <!-- 
      <p>Cleanliness can only be assessed with reference to elements in the TEI namespace. </p>

-->

      <div type="div4" xml:id="MDMDSU">
        <head>Deletion of Elements</head>

        <p>The simplest way to modify the supplied modules is to suppress one or more of the
          supplied elements. This is simply done by setting the <att>mode</att> attribute to
            <val>delete</val> on an <gi>elementSpec</gi> for the element concerned. </p>

        <p>For example, if the <gi>note</gi> element is not to be used in a particular application,
          but has been included via one of the supplied modules, then the schema specification
          concerned will contain a declaration like the following: <egXML
            xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND"><elementSpec
              ident="note" mode="delete"/></egXML> The <att>ident</att> attribute here supplies the
          canonical name of the element to be deleted and the <att>mode</att> attribute specifies
          what is to be done with it. There is no need to specify the module concerned, since
          element names are unique across all TEI modules. The full specification for a schema in
          which this modification is applied would thus be something like the following: <egXML
            xmlns="http://www.tei-c.org/ns/Examples" source="#UND"><schemaSpec ident="mySchema">
              <moduleRef key="core"/>
              <!-- other modules used by this customization -->
              <elementSpec ident="note" mode="delete"/>
            </schemaSpec></egXML>
        </p>

        <p>In most cases, deletion is a clean modification, since most elements are optional.
          Documents that are valid with respect to the modified schema are also valid according to
          TEI-All. To say this another way, the set of documents matching the new schema is
          contained by the set of documents matching the original schema.</p>

        <p>There are however some elements in the TEI schema which have mandatory children; for
          example, the element <gi>listPerson</gi> must contain at least one element from the
            <ident>model.personLike</ident> class. If that class has no members because all of its
          member elements have been removed, then the content model cannot be satisfied. A
          modification which keeps <gi>listPerson</gi> but removes all of its possible children
          would therefore be regarded as unclean. So long as at least one member of the class
          remains available, however, deleting other members would not have this effect, and would
          therefore be regarded as a clean modification. </p>

        <p>In general, whenever the element deleted by a modification is mandatory within the
          content model of some other (undeleted) element, the result is an unclean modification,
          and may also break the TEI Abstract Model (<ptr target="#CFAM"/>). However, the parent of
          a mandatory child can be safely removed if it is itself optional.</p>

        <p>To determine whether or not an element is mandatory in a given context, the user must
          inspect the content model of the element concerned. In most cases, content models are
          expressed in terms of model classes rather than elements; hence, removing an element will
          generally be a clean modification, since there will generally be other members of the
          class available. If a class is completely depopulated by a modification, then the
          cleanliness of the modification will depend upon whether or not the class reference is
          mandatory or optional, in the same way as for an individual element.</p>

      </div>


      <div type="div4" xml:id="MDMDCM">
        <head>Modification of Content Models</head>

        <p>The content model for an element in the TEI schema is defined by means of a
            <gi>content</gi> element within the <gi>elementSpec</gi> which specifies it. For
          example, the specification for the element <gi>term</gi> provided by these Guidelines
          contains a <gi>content</gi> element like the following: <egXML
            xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
            <content>
              <macroRef key="macro.phraseSeq"/>
            </content>
          </egXML> This content model consists of a reference to a macro called <ident type="macro"
            >macro.phraseSeq</ident>. Further examination shows that this macro in turn expands to
          an optional repeatable alternation of text (<gi>textNode</gi>) with references to three
          other classes (<ident type="class">model.gLike</ident>, <ident type="class"
            >model.phrase</ident>, or <ident type="class">model.global</ident>). For some particular
          application it might be preferable to insist that <gi>term</gi> elements should only
          contain plain text, excluding these other possibilities.<note place="bottom">Excluding
              <ident type="class">model.gLike</ident> is generally inadvisable however, since
            without it the resulting schema has no way of referencing non-Unicode characters.</note>
          This could be achieved simply by supplying a specification for <gi>term</gi> like the
          following: <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" rend="full"
            source="#UND"><elementSpec ident="term" module="core" mode="change">
              <content xmlns:rng="http://relaxng.org/ns/structure/1.0">
                <textNode/>
              </content>
            </elementSpec></egXML>
        </p>

        <p>This is a clean modification which does not change the meaning of a TEI element; there is
          therefore no need to assign the element to some other namespace than that of the TEI,
          though it may be considered good practice; see further <ptr target="#MDNS"/> below. </p>
        <p>A change of this kind, which simplifies the possible content of an element by reducing
          its model to one of its existing components, is always clean, because the set of documents
          matched by the resulting schema is a subset of the set of documents which would have been
          matched by TEI-All.</p>

        <p>Note that content models are generally defined (as far as possible) in terms of
          references to model classes, rather than to explicit elements. This means that the need to
          modify content models is greatly reduced: if an element is deleted or modified, for
          example, then the deletion or modification will be available for every content model which
          references that element via its class, as well as those which reference it explicitly. For
          this reason it is not (in general) good practice to replace class references by explicit
          element references, since this may have unintended side effects. </p>

        <p>An unqualified reference to an element class within a content model generates a content
          model which is equivalent to an alternation of all the members of the class referenced.
          Thus, a content model which refers to the model class <ident type="class"
            >model.phrase</ident> will generate a content model in which any one of the members of
          that class is equally acceptable. The <gi>classRef</gi> element used to reference a class
          has an <att>expand</att> attribute which may be used to vary this behaviour, for example
          to require <q>an optional repeatable alternation of all members of a class</q>, <q>a
            sequence containing no more than one of each member of the class</q>, etc. as described
          further in <ptr target="#TDCLA"/>. </p>

        <p>Content model changes which are not simple restrictions on an existing model should be
          undertaken with caution. The set of documents matching the schema which results from such
          changes is unlikely to be contained by the set of documents matching TEI-All, and such
          changes are therefore regarded as unclean. When content models are changed or extended,
          care should be taken to respect the existing semantics of the element concerned as stated
          in these Guidelines. For example, the element <gi>l</gi> is defined as containing a line
          of verse. It would not therefore make sense to redefine its content model so that it could
          also include members of the class <ident type="class">model.pLike</ident> such as
            <gi>p</gi> or <gi>ab</gi>. Although syntactically feasible, such a modification would
          not be regarded as TEI-conformant because it breaks the TEI Abstract Model. </p>

      </div>


      <div type="div4" xml:id="MDMDAL">
        <head>Modification of Attribute and Attribute Value Lists</head>

        <p>The attributes applicable to a given element may be specified in two ways: they may be
          given explicitly, by means of an <gi>attList</gi> element within the corresponding
            <gi>elementSpec</gi>, or they may be inherited from an attribute class, as specified in
          the <gi>classes</gi> element. To add a new attribute to an element, the designer should
          therefore first check to see whether this attribute is already available from some
          existing attribute class. If it is, then the simplest method of adding it will be to make
          the element in question a member of that class, as further discussed below. If this is not
          possible, then a new <gi>attDef</gi> element must be added to the existing
            <gi>attList</gi> for the element in question. </p>

        <p>Whichever method is adopted, the modification capabilities are the same as those
          available for elements. Attributes may be added or deleted from the list, using the
            <att>mode</att> attribute on <gi>attDef</gi> in the same way as on <gi>elementSpec</gi>.
          The <q>content</q> of an attribute is defined by means of the <gi>datatype</gi>,
            <gi>valList</gi>, or <gi>valDesc</gi> elements within the <gi>attDef</gi> element. Any
          of these elements may be changed. </p>

        <p>Suppose, for example, that we wish to add two attributes to the <gi>eg</gi> element (used
          to indicate examples in a text), <att>type</att> to characterize the example in some way,
          and <att>valid</att> to indicate whether the example is considered valid or not. A quick
          glance through the Guidelines indicates that the attribute class <ident type="class"
            >att.typed</ident> could be used to provide the <att>type</att> attribute, but there is
          no comparable class which will provide a <att>valid</att> attribute. The existing
            <gi>eg</gi> element in fact has no local attributes defined for it at all: we will
          therefore need to add not only an <gi>attDef</gi> element to define the new attribute, but
          also an <gi>attList</gi> to hold it. </p>
        <p>We begin by adding the new <att>valid</att> attribute: <egXML source="#NONE"
            xmlns="http://www.tei-c.org/ns/Examples" rend="full"><elementSpec ident="eg"
              module="tagdocs" mode="change">
              <attList>
                <attDef ident="valid" mode="add" ns="http://www.example.com/ns/nonTEI">
                  <desc>indicates whether or not the example is considered to be valid</desc>
                  <datatype>
                    <dataRef key="teidata.truthValue"/>
                  </datatype>
                </attDef>
              </attList>
            </elementSpec></egXML>
        </p>
        <p>The value supplied for the <att>mode</att> attribute on the <gi>attDef</gi> element is
            <val>add</val>; if this attribute already existed on the element we are modifying this
          should generate an error, since a specification cannot have more than one attribute of the
          same name. If the attribute is already present, we can replace the whole of the existing
          declaration by supplying <val>replace</val> as the value for <att>mode</att>;
          alternatively, we can change some parts of an existing declaration only by supplying just
          the new parts, and setting <val>change</val> as the value for <att>mode</att>.</p>

        <p>Because the new attribute is not defined by the TEI, it is good practice to specify a
          namespace for it on the <gi>attDef</gi>; see further <ptr target="#MDNS"/>.</p>


        <p>As noted above, adding the new <att>type</att> attribute involves changing this element's
          class membership; we therefore discuss that in the next section (<ptr target="#MDMDCL"
          />).</p>

        <p>The canonical name for the new attribute is <att>valid</att>, and is supplied on the
            <att>ident</att> attribute of the <gi>attDef</gi> element. In this simple example, we
          supply only a description and datatype for the new attribute; the former is given by the
            <gi>desc</gi> element, and the latter by the <gi>datatype</gi> element. (There are of
          course many other pieces of information which could be supplied, as documented in <ptr
            target="#TD"/>). The content of the <gi>datatype</gi>
          element<!--, like that of the
	  <gi>content</gi> element, may use patterns from the RELAX NG namespace directly,
	  rather than the TEI <soCalled>Pure ODD</soCalled> elements shown here.-->
          is a <gi>dataRef</gi> element which references an existing TEI data specification.</p>

        <p>It is often desirable to constrain the possible values for an attribute to a greater
          extent than is possible by simply supplying a TEI datatype for it. This facility is
          provided by the <gi>valList</gi> element, which can also appear as a child of the
            <gi>attDef</gi> element. Suppose for example that, rather than simply indicating whether
          or not the example is considered valid by means of the values <val>true</val> and
            <val>false</val> we wish to provide a more nuanced indication, using encoded values such
          as A, B, and C. A declaration like the following might be appropriate: <egXML
            source="#NONE" xmlns="http://www.tei-c.org/ns/Examples" rend="full">
            <elementSpec ident="eg" module="tagdocs" mode="change">
              <attList>
                <attDef ident="valid" ns="http://www.example.com/ns/nonTEI" mode="add">
                  <desc>indicates the validity of the example by supplying one of three predefined
                    codes for it.</desc>
                  <datatype>
                    <dataRef key="teidata.enumerated"/>
                  </datatype>
                  <valList type="closed">
                    <valItem ident="A">
                      <desc>validity is of the highest class</desc>
                    </valItem>
                    <valItem ident="B">
                      <desc>validity is of the second highest class</desc>
                    </valItem>
                    <valItem ident="C">
                      <desc>validity is of the lowest class</desc>
                    </valItem>
                  </valList>
                </attDef>
              </attList>
            </elementSpec></egXML>
        </p>

        <p>The same technique may be used to replace or extend the <gi>valList</gi> supplied as part
          of any attribute in the TEI schema.</p>

        <!--<p>Depending on the modification, the set of documents matched by a schema generated from an
          ODD modified in this way, may or may not be a subset of the set of documents matched by
          the unmodified schema. As such, it is difficult to tell in principle whether such
          modifications are intrinsically unclean. </p>
-->
      </div>
      <div type="div4" xml:id="MDMDCL">
        <head>Class Modification</head>

        <p>The concept of element classes was introduced in <ptr target="#STECCM"/>; an
          understanding of it is fundamental to successful use of the TEI system. As noted there, we
          distinguish <term>model classes</term>, the members of which all have structural
          similarity, from <term>attribute classes</term>, the members of which simply share a set
          of attributes. </p>
        <p>The part of an element specification which determines its class membership is an element
          called <gi>classes</gi>. All classes to which the element belongs must be specified within
          this, using a <gi>memberOf</gi> element for each. </p>
        <p>To add an element to a class in which it is not already a member, all that is needed is
          to supply a new <gi>memberOf</gi> element within the <gi>classes</gi> element for the
          element concerned. For example, to add an element to the <ident type="class"
            >att.typed</ident> class, we include a declaration like the following: <egXML
            xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" rend="full" source="#UND"
              ><elementSpec ident="eg" module="tagdocs" mode="change"
              ns="http://www.example.com/ns/nonTEI">
              <classes mode="change">
                <memberOf key="att.typed"/>
              </classes>
            </elementSpec></egXML> Any existing class memberships for the element being changed are
          not affected because the <att>mode</att> attribute of the <gi>classes</gi> element is set
          to <val>change</val> (rather than its default value of <val>replace</val>). Consequently,
          in this case, the <gi>eg</gi> element retains its membership of the two classes (<ident
            type="class">model.common</ident> and <ident type="class">model.graphicLike</ident>) to
          which it already belongs. </p>
        <p>Equally, to remove the attributes which an element inherits from its membership in some
          class, all that is needed is to remove the relevant <gi>memberOf</gi> element. For
          example, the element <gi>term</gi> defined in the core module is a member of two attribute
          classes, <ident type="class">att.typed</ident> and <ident type="class"
            >att.declaring</ident>. It inherits the attributes <att>type</att> and
            <att>subtype</att> from the former, and the attribute <att>decls</att> from the latter.
          To remove the last of these attributes from this element, we need to remove it from that
          class: <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" rend="full"
            source="#UND"><elementSpec ident="term" module="core" mode="change">
              <classes mode="change">
                <memberOf key="att.declaring" mode="delete"/>
              </classes>
            </elementSpec></egXML>
        </p>
        <p>If the intention is to change the class membership of an element completely, rather than
          simply add or remove it to or from one or more classes, the value of the <att>mode</att>
          attribute of <gi>classes</gi> can be set to <val>replace</val> (which is the default if no
          value is specified), indicating that the memberships indicated by its child
            <gi>memberOf</gi> elements are the only ones applicable. Thus the following declaration:
            <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" rend="full" source="#UND"
              ><elementSpec ident="term" module="core" mode="change"
              ns="http://www.example.com/ns/nonTEI">
              <classes mode="replace">
                <memberOf key="att.interpLike"/>
              </classes>
            </elementSpec></egXML> would have the effect of removing the element <gi>term</gi> from
          both its existing attribute classes, and adding it to the <ident type="class"
            >att.interpLike</ident> class.</p>
        <p>If however the <att>mode</att> attribute is set to <val>change</val>, the implication is
          that the memberships indicated by its child <gi>memberOf</gi> elements are to be combined
          with the existing memberships for the element. </p>

        <p>To change or remove attributes inherited from an attribute class for all members of the
          class (as opposed to specific members of that class), it is also possible to modify the
          class specification itself. For example, the class <ident type="class"
            >att.global.rendition</ident> defines several attributes which are available for all
          elements, namely <att>rend</att>, <att>style</att>, and <att>rendition</att>. If we decide
          that we never wish to use the <att>rend</att> attribute, the simplest way of removing it
          is to supply a modified class specification for <ident type="class"
            >att.global.rendition</ident> as follows: <egXML
            xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND"><classSpec
              ident="att.global.rendition" type="atts" mode="change">
              <attList>
                <attDef ident="rend" mode="delete"/>
              </attList>
            </classSpec>
          </egXML> Because the <att>mode</att> attribute on the <gi>classSpec</gi> defining the
          attributes inherited through membership of this class has the value <val>change</val>, any
          of its existing identifiable components not specified in the modification above will
          remain unchanged. The only effect will therefore be to delete the <att>rend</att>
          attribute from the class, and hence from all elements which are members of the class.</p>

        <p>The classes used in the TEI schema are further discussed in chapter <ptr target="#ST"/>.
          Note in particular that classes are themselves classified: the attributes inherited by a
          member of attribute class A may come to it directly from that class, or from another class
          of which A is itself a member. For example, the class <ident type="class"
            >att.global</ident> is itself a member of the classes <ident type="class"
            >att.global.linking</ident> and <ident type="class">att.global.analytic</ident>. By
          default, these two classes are predefined as empty. However, if (for example) the <ident
            type="module">linking</ident> module is included in a schema, a number of attributes
            (<att>corresp</att>, <att>sameAs</att>, etc.) are defined as members of the <ident
            type="class">att.global.linking</ident> class. All elements which are members of <ident
            type="class">att.global</ident> will then inherit these new attributes (see further
          section <ptr target="#STECAT"/>). A new attribute may thus be added to the global class in
          two ways: either by adding it to the <gi>attList</gi> defined within the class
          specification for <ident type="class">att.global</ident>; or by defining a new attribute
          class, and changing the class membership of the <ident type="class">att.global</ident>
          class to reference it. </p>


        <p>Such global changes should be undertaken with caution: in general removing existing
          non-mandatory attributes from a class will always be a clean modification, in the same way
          as removing non-mandatory elements. Adding a new attribute to a class however can be a
          clean modification only if the new attribute is labelled as belonging to some namespace
          other than the TEI.</p>

        <p>The same mechanisms are available for modification of model classes. Care should be taken
          when modifying the model class membership of existing elements since model class
          membership is what determines the content model of most elements in the TEI schema, and a
          small change may have unintended consequences. </p>


      </div>


      <div type="div4" xml:id="MDMDNE">
        <head>Addition of New Elements</head>

        <p>To add a completely new element into a schema involves providing a complete element
          specification for it. It is recommended that the <gi>classes</gi> element of this new
          declaration should include a reference to at least one TEI model class. Without such a
          reference, the new element would not otherwise be referenced by the content model of any
          other TEI element, and would therefore be inaccessible within a TEI document. It is also
          possible to modify the content models of one or more existing elements to refer to the new
          element explicitly, as discussed in <ptr target="#MDMDCM"/>
          <!-- 23.3.1.3--> but this will generally be less convenient. </p>

        <p>For example, the three elements <gi>bibl</gi>, <gi>biblFull</gi>, and <gi>biblStruct</gi>
          are all defined as members of the class <ident type="class">model.biblLike</ident>. To add
          a fourth member (say <gi scheme="imaginary">myBibl</gi>) to this class, we need to include
          in the <gi>elementSpec</gi> defining our new element a <gi>memberOf</gi> element which
          nominates the intended class: <egXML xmlns="http://www.tei-c.org/ns/Examples" rend="full"
            source="#UND"><elementSpec ident="myBibl" mode="add"
              ns="http://www.example.com/ns/nonTEI">
              <classes>
                <memberOf key="model.biblLike"/>
              </classes>
              <!-- other parts of the new declaration here -->
            </elementSpec></egXML> The other parts of this declaration will typically include a
          description for the new element and information about its content model, its attributes,
          etc., as further described in <ptr target="#TD"/>. </p>
      </div>
    
      <div type="div4" xml:id="MDMDNM">
        <head>Renaming of Elements</head>
        
        <p>Every element and other named markup construct in the TEI schema has a <term>canonical
          name</term>, usually composed of English language words or syllables: this name is supplied as the value of the
          <att>ident</att> attribute on the <gi>elementSpec</gi>, <gi>attDef</gi>,
          <gi>classSpec</gi>, or <gi>macroSpec</gi> used to define it. In some circumstances, it may be
          convenient for the element or attribute
          declaration used within a schema generated from that specification to take a different form, for example, permitting schemas to use generic identifiers
          from a different language, or in an abbreviated form. There may be many alternative
          identifiers for the same markup construct, and an ODD processor may choose which of them
          to use for a given purpose. Each such alternative name is supplied by means of an
          <gi>altIdent</gi> element within the specification element concerned.</p>
        <p>For example, the following declaration converts <gi>note</gi> to <gi scheme="imaginary"
          >nt</gi>: <egXML source="#NONE" xmlns="http://www.tei-c.org/ns/Examples"
            xml:lang="und"><elementSpec ident="note" module="core" mode="change">
              <altIdent>nt</altIdent>
            </elementSpec></egXML> Note that the <att>mode</att> attribute on the
          <gi>elementSpec</gi> now takes the value <val>change</val> to indicate that those parts
          of the element specification not supplied are to be inherited from the standard
          definition. The content of the <gi>altIdent</gi> element is now available for use in place of the
          canonical <att>ident</att> value in the schema generated. </p>
        
        <p>Renaming in this way is <!--always a <term>reversible</term> modification. Although it--> is an
          inherently unclean modification (because the set of documents matched by the resulting
          schema is not contained by the set matched by TEI-All), even though the process of
          converting any document in which elements have been renamed into an exactly equivalent
          document using canonical names is completely deterministic<!--, and requires only access to the
          ODD in which the renaming has been specified-->. Documents using such a schema should not claim to be
          in the TEI namespace,  but either use a null namespace or some user-defined
          namespace, as further discussed in <ptr target="#MDNS"/>; this is necessary to
          avoid the risk of name collision between the new name and all existing TEI names as well as for reasons
          of conformance
          (see further <ptr target="#MD"/>).</p>
        
      </div>
  
    </div>

    <div type="div3" xml:id="MDNS">
      <head>Modification and Namespaces</head>


      <p>All the elements defined by the TEI schema are labelled as belonging to a single
          <term>namespace</term>, maintained by the TEI and with the URI
          <val>http://www.tei-c.org/ns/1.0</val>.<note place="bottom">This is not strictly the case,
          since the element <gi>egXML</gi> used to represent TEI examples has its own namespace,
            <val>http://www.tei-c.org/ns/Examples</val>; this is the only exception however. </note>
        Only elements which are unmodified or which have undergone a clean modification may use this
        namespace. Note however that TEI-defined attributes are not associated with any namespace.
        <!--n a TEI-conformant document, it is assumed that all attributes not explicitly
        labelled with a namespace (such as, for example <att>xml:id</att>) also belong to the TEI
        namespace, and are defined by the TEI. --></p>

      <p>This implies that any other modification
        <!--(including a renaming or reversible modification)--> must either specify a different
        namespace or, equivalently, specify no namespace at all. The <att>ns</att> attribute is
        provided on elements <gi>schemaSpec</gi>, <gi>elementSpec</gi>, and <gi>attDef</gi> for this
        purpose. </p>
      <p>Suppose, for example, that we wish to add a new attribute <att scheme="imaginary"
          >topic</att> to the existing TEI element <gi>p</gi>. In the absence of namespace
        considerations, this would be an unclean modification, since <gi>p</gi> does not currently
        have such an attribute. The most appropriate action is to explicitly attach the new
        attribute to a new namespace by a declaration such as the following: <egXML source="#NONE"
          xmlns="http://www.tei-c.org/ns/Examples" rend="full">
          <elementSpec ident="p" mode="change">
            <attList>
              <attDef ident="topic" mode="add" ns="http://www.example.org/ns/nonTEI">
                <desc>indicates the topic of a TEI paragraph</desc>
                <datatype><dataRef key="teidata.word"/></datatype>
              </attDef>
            </attList>
          </elementSpec></egXML>
      </p>
      <p>Document instances using a schema derived from this ODD can now indicate clearly the status
        of this attribute: <egXML source="#NONE" xmlns="http://www.tei-c.org/ns/Examples"
          rend="full">
          <div xmlns:my="http://www.example.org/ns/nonTEI">
            <!-- ... -->
            <p n="12" my:topic="rabbits">Flopsy, Mopsy, Cottontail, and Peter...</p>
          </div></egXML></p>

      <p>Since <att scheme="imaginary">topic</att> is explicitly labelled as belonging to something
        other than the TEI namespace, we regard the modification which introduced it as clean. A
        namespace-aware processor will be able to validate those elements in the TEI namespace
        against the unmodified schema.<note place="bottom">Full namespace support does not exist in
          the DTD language, and therefore these techniques are available only to users of more
          modern schema languages such as RELAX NG or W3C Schema.</note></p>

      <p>Similar considerations apply when modification is made to the content model or some other
        aspect of an element, or when a new element is declared.
        <!--Clean modification requires that
        all -->All such changes should be explicitly
        labelled as belonging to some non-TEI namespace or to no namespace at all.</p>
      <p>If the <att>ns</att> attribute is supplied on a <gi>schemaSpec</gi> element, it identifies
        the namespace applicable to all components of the schema being specified. Even if such a
        schema includes unmodified modules from the TEI namespace, the elements contained by such
        modules will now be regarded as belonging to the namespace specified on the
          <gi>schemaSpec</gi>. This can be useful if it is desired simply to avoid namespace
        processing. For example, the following schema specification results in a schema called
          <ident>noName</ident> which has no namespace, even though it comprises declarations from
        the TEI <ident type="module">header</ident> module: <egXML
          xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND"><schemaSpec ns=""
            ident="noName">
            <moduleRef key="header"/>
            <!-- ... -->
          </schemaSpec></egXML>
      </p>
      <p>In addition to the TEI canonical namespace mentioned above, the TEI may also define
        namespaces for approved translations of the TEI schema into other languages.
        <!--These may be
        used as appropriate to indicate that a customization uses a standardized set of renamings.-->
        The namespace for such translations is the same as that for the canonical namespace,
        suffixed by the appropriate ISO language identifier (<ptr target="#CHSH"/>). A schema
        specification using the Chinese translation, for example, would use the namespace <ident
          type="ns">http://www.tei-c.org/ns/1.0/zh</ident>
      </p>
    </div>

    <div type="div3" xml:id="MDDO">
      <head>Documenting the Modification</head>

      <p>The elements used to define a TEI customization (<gi>schemaSpec</gi>, <gi>moduleRef</gi>,
          <gi>elementSpec</gi>, etc.) will typically be used within a TEI document which supplies
        further information about the intended use of the new schema, the meaning and application of
        any new or modified elements within it, and so on. This document will typically conform to a
        <!-- TEI (or other) --> schema which includes components from the module described in
        chapter <ptr target="#TD"/>.<note place="bottom">This module can be used to document any XML
          schema, and has indeed been used to document several non-TEI schemas.</note></p>
      <p>Where the customization to be documented simply consists in a selection of TEI modules,
        perhaps with some deletion of unwanted elements or attributes, the documentation need not
        specify anything further. Even here however it may be considered worthwhile to replace some
        of the semantic information provided by the unmodified TEI specification. For example, the
          <gi>desc</gi> element of an unmodified TEI <gi>elementSpec</gi> may describe an element in
        terms more general than appropriate to a particular project, or the <gi>exemplum</gi>
        elements within it may not illustrate the project's actual intended usage of the element, or
        the <gi>remarks</gi> element may contain discussions of matters irrelevant to the project.
        These elements may therefore be replaced or deleted within an <gi>elementSpec</gi> as
        necessary. </p>

      <!-- example needed -->

      <p>Radical revision is also possible. It is feasible to produce a modification in which the
          <gi>teiHeader</gi> or <gi>text</gi> elements are not required, or in which any other rule
        stated in these Guidelines is either not enforced or not enforceable. In fact, the
        mechanism, if used in an extreme way, permits replacement of all that the TEI has to say
        about every component of its schema. Such revisions would result in documents that are not
        TEI-conformant in even the broadest sense, and it is not intended that encoders use the
        mechanism in this way. We discuss exactly what is meant by the concept of <term>TEI
          conformance</term> in the next section, <ptr target="#CF"/>. </p>
    </div>



    <div type="div3" xml:id="MDlite">
      <head>Examples of Modification </head>

      <p>Several examples of customizations of the TEI are provided as part of the standard release.
        They include the following: <list type="gloss">
          <label>tei_bare</label>
          <item>The schema generated from this customization is the minimum needed for TEI
            Conformance. It provides only a handful of elements. </item>
          <label>tei_all</label>
          <item>The schema generated from this customization combines all available TEI modules,
            providing <?insert totalElements?> elements.</item>
          <label>tei_allPlus</label>
          <item>The schema generated from this customization combines all available TEI modules with
            three other non-TEI vocabularies, specifically MathML, SVG, and XInclude.</item>
        </list>
      </p>
      <p>It is unlikely that any project would wish to use any of these extremes unchanged. However,
        they form a useful starting point for customization, whether by removing modules from
        tei_all or tei_allPlus, or by replacing elements deleted from tei_bare. They also
        demonstrate how an ODD document may be constructed to provide a basic reference manual to
        accompany schemas generated from it.</p>

      <p>Shortly after publication of the first edition of these Guidelines, as a demonstration of
        how the TEI encoding schema might be adopted to meet 90% of the needs of 90% of the TEI user
        community, the TEI editors produced a brief tutorial defining one specific
          <soCalled>clean</soCalled> modification of the TEI schema, which they called TEI Lite.
        This tutorial and its associated DTD became very popular and are still available from the
        TEI web site at <ptr target="http://www.tei-c.org/Guidelines/Customization/Lite/"/>. The
        tutorial and associated schema specification is also included as one of the exemplars
        provided with TEI P5. </p>
      <p>An updated and expanded version of this schema known as <ident>TEI simplePrint</ident> was
        added to the Exemplars at release 3.1.0. The elements it defines have been modified to take
        advantage of the <soCalled>processing model</soCalled> features (see further <ptr
          target="#TDPM"/>) introduced to the Guidelines at release 3.0.0. </p>
      <p>The exemplars provided with TEI P5 also include a customization file from which a schema
        for the validation of other customization files may be generated. This ODD, called tei_odds,
        combines the four basic modules with the tagdocs, dictionaries, gaiji, linking, and figures
        modules and also provides facilities for including RELAX NG or Schematron code within a
        document.
        <!--as well as including the (non-TEI) module defining the RELAX NG language. This
        enables schemas derived from this customization file to validate examples contained within
        them in a number of ways, further described within the document.--></p>
    </div>




  </div>



  <div type="div2" xml:id="CF">

    <head>Conformance</head>

    <p>The notion of <term>TEI Conformance</term> is intended to assist in the description of the
      format and contents of a particular XML document instance or set of documents. It may be found
      useful in such situations as: <list rend="bulleted">
        <item> interchange or integration of documents amongst different researchers or users; </item>
        <item>software specifications for TEI-aware processing tools; </item>
        <item> agreements for the deposit of texts in, and distribution of texts from, archives; </item>
        <item> specifying the form of documents to be produced by or for a given project. </item>
      </list> It is not intended to provide any other evaluation, for example of scholarly merit,
      intellectual integrity, or value for money. A document may be of major intellectual importance
      and yet not be TEI-conformant; a TEI-conformant document may be of no scholarly value
      whatsoever.</p>

    <p>In this section we explore several aspects of conformance, and in particular attempt to
      define how the term <term>TEI-conformant</term> should be used. The terminology defined here
      should be considered normative: users and implementors of the TEI Guidelines should use the
      phrases <soCalled>TEI-conformant</soCalled><!--, <soCalled>TEI-conformable</soCalled>,--> and
        <soCalled>TEI Extension</soCalled> only in the senses given and with the usages described. </p>

    <p> A document is <term>TEI-conformant</term> if it: <list rend="bulleted">
        <item> is a well-formed XML document (<ptr target="#CFWF"/>)</item>
        <item>can be validated against a <term>TEI Schema</term>, that is, a schema derived from the
          TEI Guidelines (<ptr target="#CFVL"/>)</item>
        <item> conforms to the TEI Abstract Model (<ptr target="#CFAM"/>)</item>
        <item> uses the <term>TEI namespace</term> (and other namespaces where relevant) correctly
            (<ptr target="#CFNS"/>)</item>
        <item> is documented by means of a TEI-conformant <term>ODD file</term> (<ptr target="#CFOD"
          />) which refers to the TEI Guidelines </item>
      </list> Each of these criteria is discussed in more detail below. </p>

    <!--
    <p>A document is said to be <term>TEI-conformable</term> if it is a well-formed XML document
      which can be transformed algorithmically and automatically into a TEI-conformant document as
      defined above without loss of information. Such a document may informally be described as
      TEI-conformant; the terms <term>algorithmically conformant</term> or
        <term>TEI-conformable</term> are provided in order to distinguish documents exhibiting these
      kinds of conformance from others.</p>-->

    <p>A document is said to use a <term>TEI Extension</term> if it is a well-formed XML document
      which is valid against a TEI Schema which contains additional distinctions, representing
      concepts not present in the TEI Abstract Model, and therefore not documented in these
      Guidelines. Such a document <!--cannot, in general, be algorithmically conformant since it-->
      cannot necessarily be transformed automatically to a TEI-conformant document without loss of
      information. However, since one of the goals of the TEI is to support extensions and
      modifications, it should not be assumed that no TEI document can include extensions: an
      extension which is expressed by means of the recommended mechanisms is also a TEI-conformant
      document provided that those parts of it which are not extensions are
      TEI-conformant<!--, or -conformable-->.</p>

    <p>A TEI-conformant <!--(or -conformable) -->document is said to follow <term>TEI Recommended
        Practice</term> if, wherever these Guidelines prefer one encoding practice to another, the
      preferred practice is used.</p>

    <div type="div3" xml:id="CFWF">

      <head>Well-formedness Criterion</head>

      <p>These Guidelines mandate the use of well-formed XML as representation format. Documents
        must conform to the World Wide Web Consortium recommendation of the <title>Extensible Markup
          Language (XML) 1.0 (Fourth Edition)</title> or successor editions found at <ptr
          target="https://www.w3.org/TR/xml/"/>. Other ways of
        representing the concepts of the TEI Abstract Model are possible, and other representations
        may be considered appropriate for use in particular situations (for example, for data
        capture, or project-internal processing). But such alternative representations
        <!--are at best
          <soCalled>TEI-conformable</soCalled>, and cannot --> should not be
        considered in any way TEI-conformant.</p>

      <p>Previous versions of these Guidelines used SGML as a representation format. With the
        release of P5, the only representation format supported by these Guidelines became valid
        XML; legacy documents in SGML format should therefore be converted using appropriate
        software.</p>
      <p>A TEI-conformant document must use the TEI namespace, and therefore must also include an
        XML-conformant namespace declaration, as defined below (<ptr target="#CFNS"/>).</p>
      <p>The use of XML greatly reduces the need to consider hardware or software differences
        between processing environments when exchanging data. No special packing or interchange
        format is required for an XML document, beyond that defined by the W3C recommendations, and
        no special <soCalled>interchange</soCalled> format is therefore proposed by these
        Guidelines. For discussion of encoding issues that may arise in the processing of special
        character sets or non-standard writing systems, see further chapter <ptr target="#CH"/>.</p>

      <p>In addition to the well-formedness criterion, the W3C defines the notion of a
          <term>valid</term> document, as being a well-formed document which matches a specific set
        of rules or syntactic constraints, defined by a <term>schema</term>. As noted above, TEI
        conformance implies that the schema used to determine validity of a given document should be
        derived from the present Guidelines, by means of an ODD which references and documents
        components <!-- the
        schema fragments -->which these Guidelines define. </p>
    </div>

    <div type="div3" xml:id="CFVL">
      <head>Validation Constraint</head>

      <p>All <term>TEI-conformant</term> documents must validate against a schema file that has been
        derived from the published TEI Guidelines, combined and documented in the manner described
        in section <ptr target="#MD"/>. We call the formal output of this process a <term>TEI
          Schema</term>. </p>

      <p>The TEI does not mandate use of any particular schema language, only that this schema<note
          place="bottom">Here and elsewhere we use the word <mentioned>schema</mentioned> to refer
          to any formal document grammar language, irrespective of the formalism used to represent
          it.</note> should have been generated from a <term>TEI ODD file</term> that references the
        TEI Guidelines. Currently available tools permit the expression of schemas in any or all of
        the XML DTD language, W3C XML Schema, and RELAX NG (both compact and XML formats). Some of
        what is syntactically possible using the ODD formalism cannot be represented by all schema
        languages; and there are some features of some schema languages which have no counterpart in
        ODD. No single schema language fully captures all the constraints implied by conformance to
        the TEI Abstract Model. A document which is valid according to a TEI schema represented
        using one schema language may not be valid against the same schema expressed in other
        languages; for example, the DTD language does not <!--fully--> support namespaces.
        <!--Features which
        cannot be represented in all schema languages are documented in chapters <ptr target="#TD"/>
        and <ptr target="#IM"/>. --></p>

      <p>As noted in section <ptr target="#MD"/>, many varieties of TEI schema are possible and not
        all of them are necessarily <term>TEI-conformant</term>; derivation from an ODD is a
        necessary but not a sufficient condition for TEI Conformance.</p>


    </div>

    <div type="div3" xml:id="CFAM">

      <head>Conformance to the TEI Abstract Model</head>

      <p>The <term>TEI Abstract Model</term> is the conceptual schema instantiated by the TEI
        Guidelines. These Guidelines define, both formally and informally, a set of abstract
        concepts such as <q>paragraph</q> or <q>heading</q>, and their structural relationships, for
        example stating that <soCalled>paragraph</soCalled>s do not contain
          <soCalled>heading</soCalled>s. These Guidelines also define classes of elements, which
        have both semantic and structural properties in common. Those semantic and structural
        properties are also a part of the TEI Abstract Model; the class membership of an existing
        TEI element cannot therefore be changed without changing the model. Elements can however be
        removed from a class by deletion, and new non-TEI elements within their own namespaces can
        be added to existing TEI classes.</p>


      <div type="div4" xml:id="CFAMsc">
        <head>Semantic Constraints</head>

        <p>It is an important condition of TEI conformance that elements defined in the TEI
          Guidelines as having one specific meaning should not be used with another. For example,
          the element <gi>l</gi> is defined in the TEI Guidelines as containing a line of verse. A
          schema in which it is redefined to mean a typographic line, or an ordered queue of objects
          of some kind, cannot therefore be TEI-conformant, whatever its other properties.</p>

        <p>The semantics of elements defined in the TEI Guidelines are conveyed in a number of ways,
          ranging from formally verifiable datatypes to informal descriptive prose. In addition, a
          mapping between TEI elements and concepts in other conceptual models may be provided by
          the <gi>equiv</gi> element where this is available. </p>

        <p>A schema which shares equivalent concepts to those of the TEI conceptual model may be
          mappable to the TEI Schema by means of such a mechanism. For example, the concept of
          paragraph expressed in the TEI schema by the <gi>p</gi> element is probably the same
          concept as that expressed in the DocBook schema by the <gi scheme="DBK">para</gi> element.
          <!--In this respect (though not in others) a DocBook-conformant document might therefore be
          considered to be TEI-conformable. -->Such
          areas of overlap facilitate
          interchange<!--2019-06-17 ebb: I've changed this from interoperability to interchange, which seems more accurate. -->
          because elements from one namespace may be readily integrated with those from another, but
          do not affect the definition of conformance.</p>

        <p>A document is said to conform to the <term>TEI Abstract Model</term> if features for
          which an encoding is proposed by the TEI Guidelines are encoded within it using the markup
          and other syntactic properties defined by means of a valid <term>TEI-conformant</term>
          schema. Hence, even though the names of elements or attributes may vary, a TEI-conformant
          document must respect the TEI Semantic Model, and be valid with respect to a
          TEI-conformant Schema. Although it may be possible to transform a document which follows
          the <term>TEI Abstract Model</term> into a <term>TEI-conformant</term> document, such a
          document is not itself<!-- necessarily--> conformant.</p>
        <p>As noted above, the notion of semantic conformance cannot be completely enforced in a
          formal way. The TEI conceptual model is expressed by means of formal specification in a
          customization file, by means of descriptive prose in the body of these Guidelines, and
          implicitly by examples of usage. Any inconsistency between, for example, the text of these
          Guidelines and a part of a specification should be considered an error and reported to the
          TEI Council for correction. </p>

      </div>

      <div type="div4" xml:id="CFAMmc">
        <head>Mandatory Components of a TEI Document</head>

        <p>It is a long-standing requirement for any <term>TEI-conformant</term> document that it
          should contain a <gi>teiHeader</gi> element. To be more specific a
            <term>TEI-conformant</term> document must contain <list>
            <item> a single <gi>teiHeader</gi> element followed by one or more elements from the
                <ident type="class">model.resource</ident> class; or</item>
            <item> in the case of a corpus or collection, a single overall <gi>teiHeader</gi>
              element followed by a series of <gi>TEI</gi> elements each with its own
                <gi>teiHeader</gi></item>
          </list> All <gi>teiHeader</gi> elements in a <term>TEI-conformant</term> document must
          include elements for: <list type="gloss">
            <label>Title Statement</label>
            <item>This should include the title of the TEI document expressed using a
                <gi>titleStmt</gi> element.</item>
            <label>Publication Statement</label>
            <item>This should include the place and date of publication or distribution of the TEI
              document, expressed using the <gi>publicationStmt</gi> element.</item>
            <label>Source Statement</label>
            <item>For a document derived from some previously existing document, this must include a
              bibliographic description of that source. For a document not so derived, this must
              include a brief statement that the document has no pre-existing source. In either
              case, this will be expressed using the <gi>sourceDesc</gi> element. </item>
          </list></p>

      </div>

    </div>


    <div type="div3" xml:id="CFNS">
      <head>Use of the <term>TEI Namespace</term></head>

      <p>The Namespaces Recommendation of the W3C (<ptr target="#NAMESPACES"/>) provides a way for
        an XML document to combine markup from different vocabularies without risking name collision
        and consequent processing difficulties. While the scope of the TEI is large, there are many
        areas in which it makes no particular recommendation, or where it recommends that other
        defined markup schemas should be adopted, such as graphics or mathematics. It is also
        considered desirable that users of other markup schemas should be able to integrate
        documents using TEI markup with their own system. To meet these objectives without
        compromising the reliability of its encoding, a TEI-conformant document is required to make
        appropriate use of the TEI namespace.</p>

      <p>Essentially all elements in a TEI Schema which represents concepts from the TEI Abstract
        Model belong to the TEI namespace, <ident type="ns">http://www.tei-c.org/ns/1.0</ident>,
        maintained by the TEI. A TEI-conformant document is required to declare the namespace for
        all the elements it contains whether these come from the TEI namespace or from other
        schemas. </p>

      <p>A TEI Schema may be created which assigns TEI elements to some other namespace, or to no
        namespace at all. A document using such a schema cannot be considered
        TEI-conformant<!--, though it may be TEI-conformable-->. A document which places non-TEI
        elements or attributes within the TEI namespace cannot be considered TEI-conformant; such
        practices are strongly deprecated as they may lead to serious difficulties for processing or
        interchange. </p>

    </div>

    <div type="div3" xml:id="CFOD">
      <head>Documentation Constraint</head>

      <p>As noted in <ptr target="#CFVL"/> above, a TEI Schema can only be generated from a TEI ODD,
        which also serves to document the semantics of the elements defined by it. A TEI-conformant
        document should therefore always be accompanied by (or refer to) a valid <term>TEI ODD
          file</term> specifying which modules, elements, classes, etc. are in use together with any
        modifications <!--or renamings -->applied, and from which a TEI Schema can be generated to
        validate the document. The TEI supplies a number of predefined <term>TEI Customization
          exemplar ODD files</term> and the schemas already generated from them (see <ptr
          target="#MDlite"/>), but most projects will typically need to customize the TEI beyond
        what these examples provide. It is assumed, for example, that most projects will customize
        the TEI schema by removing those elements that are not needed for the texts they are
        encoding, and by providing further constraints on the attribute values and element content
        models the TEI provides. All such customizations must be specified by means of a valid
          <term>TEI ODD</term> file. </p>

      <p>As different sorts of customization have different implications for the interchange and
        interoperability of TEI documents, it cannot be assumed that every customization will
        necessarily result in a schema that validates only TEI-conformant documents. The ODD
        language permits modifications which conflict with the TEI Abstract Model, even though
        observing this model is a requirement for TEI Conformance. The ODD language can in fact be
        used to describe many kinds of markup schema, including schemas which have nothing to do
        with the TEI at all. </p>

      <p>Equally, it is possible to construct a TEI Schema which is identical to that derived from a
        given TEI ODD file without using the ODD schema. A schema can constructed simply by
        combining the predefined schema language fragments corresponding with the required set of
        TEI modules and other statements in the relevant schema language. However, the status of
        such a schema with respect to the <ident type="schema">tei_all</ident> schema cannot in
        general be easily determined; it may therefore be impractical to determine whether such a
        schema represents a clean modification or an extension. This is one reason for making the
        presence of a TEI ODD file a requirement for conformance. </p>

    </div>




    <div type="div3" xml:id="CFCATSCH">
      <head>Varieties of TEI Conformance</head>

      <p>The conformance status of a given document may be assessed by answering the following
        questions, in the order indicated: <list rend="numbered">
          <item>Is it a valid XML document, for which a TEI Schema exists? If not, then the document
            cannot be considered TEI-conformant in any sense.</item>
          <item>Is the document accompanied by a TEI-conformant ODD specification describing its
            markup schema and intended semantics? If not, then the document can only be considered
            TEI-conformant if it validates against a predefined TEI Schema and conforms to the TEI
            abstract model.</item>
          <item>Does the markup in the document correctly represent the TEI abstract model? Though
            difficult to assess, this is essential to TEI conformance.</item>
          <item>Does the document claim that all of its elements come from some namespace other than
            the TEI (or no namespace)? If so, the document cannot be TEI-conformant.</item>
          <item>If the document claims to use the TEI namespace, in part or wholly, do the elements
            associated with that namespace in fact belong to it? If not, the document cannot be
            TEI-conformant; if so, and if all non-TEI elements and attributes are correctly
            associated with other namespaces, then the document may be TEI-conformant.</item>
          <item>Is the document valid according to a schema made by combining all TEI modules as
            well as valid according to the schema derived from its associated ODD specification? If
            so, the document is TEI-conformant. </item>
          <item>Is the document valid according to the schema derived from its associated ODD
            specification, but not according to <ident type="schema">tei_all</ident>? If so, the
            document uses a TEI extension. </item>
          <item>Is it possible automatically to transform the document into a document which is
            valid according to <ident type="schema">tei_all</ident>, using only information supplied
            in the accompanying ODD and without loss of information? If so, the document is
            TEI-conform<!--able-->ant.</item>
        </list>
      </p>

      <p>In the following table, we examine more closely some specific, though imaginary, cases:
          <table xml:id="tab-conformance">
          <row role="label">
            <cell/>
            <cell>A</cell>
            <cell>B </cell>
            <cell>C</cell>
            <cell>D</cell>
            <cell>E </cell>
            <cell>F</cell>
            <cell>G</cell>
            <cell>H</cell>
          </row>
          <row>
            <cell>Conforms to TEI Abstract Model</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>?</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>?</cell>
          </row>
          <row>
            <cell>Valid ODD present</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>N</cell>
          </row>
          <row>
            <cell>Uses only non-TEI namespace(s) or none</cell>
            <cell>N</cell>
            <cell>N</cell>
            <cell>N</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
          </row>
          <row>
            <cell>Uses TEI and other namespaces correctly</cell>
            <cell>Y</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
          </row>
          <row>
            <cell>Document is valid as a subset of <ident type="schema">tei_all</ident></cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
          </row>
          <row>
            <cell>Document can be converted automatically to a form which is valid as a subset of
                <ident type="schema">tei_all</ident></cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>N</cell>
            <cell>Y</cell>
            <cell>N</cell>
            <cell>?</cell>
          </row>
        </table>
      </p>
      <p>We assume firstly that each sample document assessed here is a well-formed XML document,
        and that it is valid against some schema. </p>
      <p>The document in column A is TEI-conformant. Its tagging follows the TEI Abstract Model,
        both as regards syntactic constraints (its <gi>l</gi> elements appear within <gi>div</gi>
        elements and not the reverse) and semantic constraints (its <gi>l</gi> elements appear to
        contain verse lines rather than typographic ones). It is accompanied by a valid ODD which
        documents exactly how it uses the TEI. All the TEI-defined elements and attributes in the
        document are placed in the TEI namespace. The schema against which it is valid is a
          <soCalled>clean</soCalled> subset of the <ident type="schema">tei_all</ident> schema. </p>

      <p>The document in column B is not a TEI document. Although it is accompanied by a valid TEI
        ODD, the resulting schema includes some <soCalled>unclean</soCalled> modifications, and
        represents some concepts from the TEI Abstract Model using non-TEI elements; for example, it
        re-defines the content model of <gi>p</gi> to permit <gi>div</gi> within it, and it includes
        an element <gi scheme="imaginary">pageTrimming</gi> which appears to have the same meaning
        as the existing TEI <gi>fw</gi> element, but the equivalence is not made explicit in the
        ODD. It uses the TEI namespace correctly to identify the TEI elements it contains, but the
        ODD does not contain enough information automatically to convert its non-TEI elements into
        TEI equivalents.</p>

      <p>The document in column C is <!--TEI-conformable--> TEI conformant. It is almost the same as
        the document in column A, except that the names of the elements used are not those specified
        for the TEI namespace. Because the ODD accompanying it contains an exact mapping for each
        element name (using the <gi>altIdent</gi> element) and there are no name conflicts, it is
        possible to make an automatic conversion of this document.</p>

      <p>The document in column D is a TEI Extension. It combines elements from its own namespace
        with unmodified TEI elements in the TEI namespace. Its usage of TEI elements conforms to the
        TEI Abstract Model. Its ODD defines a new <gi scheme="imaginary">blort</gi> element which
        has no exact TEI equivalent, but which is assigned to an existing TEI class; consequently
        its schema is not a clean subset of <ident type="schema">tei_all</ident>. If the associated
        ODD provided a way of mapping this element to an existing TEI element, then this would be
        TEI-conforma<!--ble-->nt.</p>

      <p>The document in column E is superficially similar to document D, but because it does not
        use any namespace declarations (or, equivalently, it assigns unmodified TEI elements to its
        own namespace), it may contain name collisions; there is no way of knowing whether a
          <gi>p</gi> within it is the same as the TEI's <gi>p</gi> or has some other meaning. The
        accompanying ODD file may be used to provide the human reader with information about
        equivalently named elements in the TEI namespace, and hence to determine whether the
        document is valid with respect to the TEI Abstract Model but this is not an automatable
        process. In particular, cases of apparent conflict (for example use of an element <gi>p</gi>
        to represent a concept not in the TEI Abstract Model but in the abstract model of some other
        system, whose namespace has been removed as well) cannot be reliably resolved. By our
        current definition therefore, this is not a TEI document.</p>

      <p>The document in column F is TEI-conforma<!--ble-->nt. The difference between it and that in
        column D is that the new element <gi scheme="imaginary">blort</gi> which is used in this
        document is a specialization of an existing TEI element, and the ODD in which it is defined
        specifies the mapping (a <gi scheme="imaginary">my:blort</gi> may be automatically converted
        to a <tag>tei:seg type="blort"</tag>, for example). For this to work, however, the <gi
          scheme="imaginary">blort</gi> must observe the same syntactic constraints as the
          <gi>seg</gi>; if it does not, this would also be a case of TEI Extension.</p>

      <p>The document in column G is not a TEI document. Its structure is fully documented by a
        valid TEI ODD, but it does not claim to represent the TEI Abstract Model, does not use the
        TEI namespace, and is not intended to validate against any TEI schema. </p>

      <p>The document in column H is very like that in column A, but it lacks an accompanying ODD.
        Instead, the schema used to validate it is produced simply by combining TEI schema fragments
        in the same way as an ODD processor would, given the ODD. If the resulting schema is a clean
        subset of <ident type="schema">tei_all</ident>, such a document is indistinguishable from a
        TEI-conformant one, but there is no way of determining (without inspection) whether this is
        the case if any modification or extension has been applied. Its status is therefore, like
        that of Text E, impossible to determine.</p>

    </div>


  </div>





  <div xml:id="IM" type="div2">
    <head>Implementation of an ODD System</head>
    <p>This section specifies how a processing system may take advantage of the markup specification
      elements documented in chapter <ptr target="#TD"/> of these Guidelines in order to produce
      project specific user documentation, schemas in one or more schema languages, and validation
      tools for other processors.</p>

    <p>The specifications in this section are illustrative but not normative. Its function is to
      further illustrate the intended scope and application of the elements documented in chapter
        <ptr target="#TD"/>, since it is believed that these may have application beyond the areas
      directly addressed by the TEI.</p>

    <p>An ODD processing system has to accomplish two main tasks. A set of selections, deletions,
      changes, and additions supplied by an ODD customization (as described in <ptr target="#MD"/>)
      must first be merged with the published TEI P5 ODD specifications. Next, the resulting unified
      ODD must be processed to produce the desired outputs.</p>

    <p>An ODD processor is not required to do these two stages in sequence, but that may well be the
      simplest approach; the ODD processing tools currently provided by the TEI Consortium, which
      are also used to process the source of these Guidelines, adopt this approach.</p>

    <div xml:id="IM-unified">
      <head>Making a Unified ODD</head>
      <p>An ODD customization must contain a single <gi>schemaSpec</gi> element, which defines the
        schema to be constructed. <specList>
          <specDesc key="schemaSpec" atts="start prefix targetLang docLang"/>
        </specList> Amongst other attributes inherited from the <ident type="class"
          >att.identified</ident> class, this element also carries a required <att>ident</att>
        attribute. This provides a name for the generated schema, which other components of the
        processing system may use to refer to the schema being generated, e.g. in issuing error
        messages or as part of the generated output schema file or files. The <att>ns</att>
        attribute may be used to specify the default namespace within which elements valid against
        the resulting schema belong, as discussed in <ptr target="#MDNS"/>. </p>
      <p>The <gi>schemaSpec</gi> element contains an unordered series of specialized elements, each
        of which is of one of the following four types: <list type="gloss">
          <label>specifications</label>
          <item>elements from the class <ident type="class">model.oddDecl</ident> (by default
              <gi>elementSpec</gi>, <gi>classSpec</gi>, <gi>moduleSpec</gi>, and
            <gi>macroSpec</gi>); these must have a <att>mode</att> attribute which determines how
            they will be processed.<note place="bottom">An ODD processor should recognize as
              erroneous such obvious inconsistencies as an attempt to include an
                <gi>elementSpec</gi> in <val>add</val> mode for an element which is already present
              in an imported module.</note> If the value of <att>mode</att> is <val>add</val>, then
            the object is simply copied to the output, but if it is <val>change</val>,
              <val>delete</val>, or <val>replace</val>, then it will be looked at by other parts of
            the process.</item>
          <label>references to specifications</label>
          <item><gi>specGrpRef</gi> elements refer to <gi>specGrp</gi> elements that occur elsewhere
            in this, or another, document. A <gi>specGrp</gi> element, in turn, groups together a
            set of ODD specifications (among other things, including further <gi>specGrpRef</gi>
            elements). The use of <gi>specGrp</gi> and <gi>specGrpRef</gi> permits the ODD markup to
            occur at the points in documentation where they are discussed, rather than all inside
              <gi>schemaSpec</gi>. The <att>target</att> attribute of any <gi>specGrpRef</gi> should
            be followed, and the <gi>elementSpec</gi>, <gi>classSpec</gi>, and <gi>macroSpec</gi>,
            elements in the corresponding <gi>specGrp</gi> should be processed as described in the
            previous item; <gi>specGrpRef</gi> elements should be processed as described
            here.</item>
          <label>references to TEI Modules</label>
          <item><gi>moduleRef</gi> elements with <att>key</att> attributes refer to components of
            the TEI. The value of the <att>key</att> attribute matches the <att>ident</att>
            attribute of the <gi>moduleSpec</gi> element defining a TEI module. The <att>key</att>
            must be dereferenced by some means, such as reading an XML file with the TEI ODD
            specification (either from the local hard drive or off the Web), or looking up the
            reference in an XML database (again, locally or remotely); whatever means is used, it
            should return a stream of XML containing the element, class, and macro specifications
            collected together in the specified module. These specification elements are then
            processed in the same way as if they had been supplied directly within the
              <gi>schemaSpec</gi> being processed.</item>

          <label>references to external modules</label>
          <item>a <gi>moduleRef</gi> element may also refer to a compatible external module by means
            of its <att>url</att> attribute; the content of such modules, which must be available in
            the RELAX NG XML syntax, are passed directly and without modification to the output
            schema when that is created. </item>
        </list>
      </p>

      <p>Each object obtained from the TEI ODD specification using <gi>moduleRef</gi> by means of
        the <att>key</att> attribute must be checked against objects in the customization
          <gi>schemaSpec</gi> according to the following rules: <list rend="numbered">
          <item>if there is an object in the ODD customization with the same value for the
              <att>ident</att> attribute, and a <att>mode</att> value of <val>delete</val>, then the
            object from the module is ignored; </item>
          <item>if there is an object in the ODD customization with the same value for the
              <att>ident</att> attribute, and a <att>mode</att> value of <val>replace</val>, then
            the object from the module is ignored, and the one from the ODD customization is used in
            its place; </item>
          <item>if there is an object in the ODD customization with the same value for the
              <att>ident</att> attribute, and a <att>mode</att> value of <val>change</val>, then the
            two objects must be merged, as described below; </item>
          <item>if there is an object in the ODD customization with the same value for the
              <att>ident</att> attribute, and a <att>mode</att> value of <val>add</val>, then an
            error condition should be raised; </item>

          <item>otherwise, the object from the module is copied to the result.</item>
        </list>
      </p>

      <p>To merge two objects with the same <att>ident</att>, their component attributes and child
        elements must be looked at recursively. Each component may fall into one of the following
        four categories: <list rend="numbered">

          <item>Some components may occur only once within the merged object (for example
            attributes, and <gi>altIdent</gi>, <gi>content</gi>, or <gi>classes</gi> elements). If
            such a component is found in the ODD customization, it will be copied to the output; if
            it is not found there, but is present in the TEI ODD specification, then that will be
            copied to the output. </item>

          <item>Some components are grouping objects (<gi>attList</gi>, <gi>valList</gi>, for
            example); these are always copied to the output, and their children are then processed
            following the rules given in this list.</item>

          <item>Some components are <soCalled>identifiable</soCalled>: this means that they are
            members of the <ident type="class">att.identified</ident> class from which they inherit
            the <att>ident</att> attribute; examples include <gi>attDef</gi> and <gi>valItem</gi>. A
            component of this type will be processed according to its <att>mode</att> attribute,
            following the rules given above.</item>

          <item>Some components may occur multiple times, but are neither grouped nor identifiable.
	    Examples include the <gi>desc</gi>, <gi>exemplum</gi>, <gi>remarks</gi>, <gi>listRef</gi>,
	    <gi>datatype</gi> and <gi>defaultVal</gi> elements, and the members of
	    <ident type="class">model.identSynonyms</ident>, i.e. the <gi>equiv</gi>,
	    <gi>altIdent</gi>, and <gi>gloss</gi>, elements. These should be copied from both the TEI
	    ODD specification and the ODD customization, and all occurrences included in the output.</item>
        </list>
      </p>

      <p>A special problem arises with elements which are members of attribute classes, as they are
        permitted to override attributes inherited from a class. For example, consider this simple
        modification: <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
          <elementSpec ident="p">
            <classes>
              <memberOf key="att.typed"/>
            </classes>
            <!-- ... -->
          </elementSpec>
        </egXML> The effect of its membership in the <ident type="class">att.typed</ident> class is
        to provide <gi>p</gi> with a <att>type</att> attribute and a <att>subtype</att> attribute.
        If we wish <gi>p</gi> to <emph>not</emph> have <att>subtype</att>, we could extend the
        customization in our schema as follows: <egXML xmlns="http://www.tei-c.org/ns/Examples"
          xml:lang="und" source="#UND">
          <elementSpec ident="p">
            <classes>
              <memberOf key="att.typed"/>
            </classes>
            <!-- ... -->
            <attList>
              <attDef ident="subtype" mode="delete"/>
            </attList>
          </elementSpec>
        </egXML> This means that when <tag>memberOf key="att.typed"/</tag> is processed, that class
        is looked up, each attribute which it defines is examined in turn, and the customization is
        searched for an override. If the modification is of the attribute class itself, work
        proceeds as usual; if, however, the modification is at the element level, the class
        reference is deleted and a series of <gi>attRef</gi> elements is added to the element, one
        for each attribute inherited from the class. Since attribute classes can themselves be
        members of other attribute classes, membership must be followed recursively.</p>

      <p>The effect of the concatenation of unidentifiable components should be considered
        carefully. An original may have <egXML xmlns="http://www.tei-c.org/ns/Examples"
          source="#NONE">
          <elementSpec ident="p">
            <desc>marks paragraphs in prose.</desc>
            <!-- ... -->
          </elementSpec>
        </egXML> which would usefully be extended with this: <egXML
          xmlns="http://www.tei-c.org/ns/Examples" xml:lang="es" source="#NONE">
          <elementSpec ident="p" mode="change">
            <desc xml:lang="es">marca pÃ¡rrafos en prosa.</desc>
            <!-- ... -->
          </elementSpec>
        </egXML> to provide an alternate description in another language. Nothing prevents the user
        from supplying <gi>desc</gi> several times in the same language, and subsequent applications
        will have to decide what that may mean.</p>

      <p>Similar considerations apply to multiple example elements, though these are less likely to
        cause problems in documentation. Note that existing examples can only be deleted by
        supplying a completely new <gi>elementSpec</gi> in <val>replace</val> mode, since the
          <gi>exemplum</gi> element is not identifiable.</p>

      <p>In the processing of the content models of elements and the content of macros, deleted
        elements may require special attention.<note place="bottom">The carthago program behind the
          Pizza Chef application, written by Michael Sperberg-McQueen for TEI P3 and P4, went to
          very great efforts to get this right. The XSLT transformations used by the P5 Roma
          application are not as sophisticated, partly because the RELAX NG language is more
          forgiving than DTDs.</note> A content model like this: <!--<egXML xml:lang="und"
            xmlns="http://www.tei-c.org/ns/Examples">
          <elementSpec ident="person">
            <!-\- ... -\->
            <content>
              <rng:choice xmlns:rng="http://relaxng.org/ns/structure/1.0">
                <rng:oneOrMore>
                  <rng:ref name="model.pLike"/>
                </rng:oneOrMore>
                <rng:zeroOrMore>
                  <rng:choice>
                    <rng:ref name="model.personPart"/>
                    <rng:ref name="model.global"/>
                  </rng:choice>
                </rng:zeroOrMore>
              </rng:choice>
            </content>
            <!-\- ... -\->
          </elementSpec>-->
        <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
          <elementSpec ident="person">
            <!-- ... -->
            <content>
              <alternate>
                <classRef key="model.pLike" minOccurs="1" maxOccurs="unbounded"/>
                <alternate minOccurs="0" maxOccurs="unbounded">
                  <classRef key="model.personPart"/>
                  <classRef key="model.global"/>
                </alternate>
              </alternate>
            </content>
            <!-- ... -->
          </elementSpec>
        </egXML> requires no special treatment because everything is expressed in terms of model
        classes; if the class <ident type="class">model.personPart</ident> is deleted explicitly, or
        removed because all of its members have been deleted, then <ident type="class"
          >model.global</ident> is left as the only child of the inner <gi>alternate</gi>. An ODD
        processor may or may not elect to simplify the resulting choice between nothing and <ident
          type="class">model.global</ident> by removing the wrapper <gi>alternate</gi> element.
        However, such simplification may be considerably more complex in the general case
        <!--(if for example the <gi>rng:choice</gi> is itself inside an
          <gi>rng:zeroOrMore</gi> inside a <gi>rng:group</gi>), -->and
        an ODD processor is therefore likely to be more successful in carrying out such
        simplification as a distinct stage during processing of ODD sources.</p>
      <p>If an element refers directly to an element child, like this: <egXML
          xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
          <elementSpec ident="figure">
            <!-- ... -->
            <content>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <classRef key="model.pLike"/>
                <classRef key="model.global"/>
                <elementRef key="figure"/>
                <elementRef key="figDesc"/>
                <classRef key="model.graphicLike"/>
                <classRef key="model.headLike"/>
              </alternate>
            </content>
            <!-- ... -->
          </elementSpec>
        </egXML> and <gi>figDesc</gi> has been deleted,<note place="bottom">Note that deletion of
          required elements will cause the schema specification to accept as valid documents which
          cannot be TEI-conformant, since they no longer conform to the TEI Abstract Model;
          conformance topics are addressed in more detail in <ptr target="#CF"/>.</note> it will be
        necessary to remove that reference, or the resulting schema will be
        invalid.<!-- Surrounding
        constructs, such as a <gi>rng:zeroOrMore</gi> (which cannot be empty), may also have to be
        removed.--></p>

      <p>The result of the work carried out should be a new <gi>schemaSpec</gi> which contains a
        complete and internally consistent set of element, class, and macro specifications, possibly
        also including <gi>moduleRef</gi> elements with <att>url</att> attributes identifying
        external modules. </p>

    </div>

    <div xml:id="IMGS">
      <head>Generating Schemas</head>
      <p>Assuming that any modifications have been resolved, as outlined in the previous section,
        making a schema is now a four stage process: <list rend="numbered">
          <item>all datatype and other macro specifications must be collected together and declared
            at the start of the output schema;</item>
          <item> all classes must be declared in the right order (order is significant because since
            some classes reference others);</item>
          <item>all elements are declared;</item>
          <item>any <gi>moduleRef</gi> elements with a <att>url</att> attribute identifying an
            external schema must be processed.</item>
        </list> Working in this order gives the best chance of successfully supporting all the
        schema languages. However, there are a number of obstacles to overcome along the way.</p>

      <p>An ODD processor may choose to use any desired schema language or languages for its schema
        output, since ODD specifications are expressed as far as possible in a form independent of
        any schema language.
        <!-- The TEI ODD specification uses RELAX NG to express content models, and is therefore biased
        towards this language. However, -->
        The current TEI ODD processing system produces schema output in the three main schema
        languages as follows: <list rend="bulleted">
          <item>A RELAX NG (XML) schema is generated by converting content models, datatypes, and
            macro specifications provided within the ODD specification; a version re-expressed in
            the RELAX NG compact syntax is generated using James Clark's <name>trang</name>
            application.</item>

          <item>A DTD schema is generated by converting the RELAX NG content models to DTD language,
            often simplifying it to allow for the less-sophisticated output language.</item>

          <item>A W3C Schema schema is created by generating a RELAX NG schema and then using James
            Clark's <name>trang</name> application.</item>
        </list> Note that the method used to generate W3C Schema means that a processor must ensure
        that the RELAX NG it generates follows the subset which <name>trang</name> is able to
        translate properly (see further below)âthis may involve simple trial and error.</p>

      <p>Other projects may decide to follow a different route, perhaps implementing a direct ODD to
        W3C Schema translator.</p>

      <p>Secondly, it is possible to create two rather different styles of schema. On the one hand,
        the schema can try to maintain all the flexibility of ODD by using the facilities of the
        schema language for parameterization; on the other, it can remove all customization features
        and produce a flat result which is not suitable for further manipulation. The TEI project
        currently generates both styles of schema; the first as a set of schema fragments in DTD and
        RELAX NG languages, which can be included as modules in other schemas, and customized
        further; the second as the output from a processor such as Roma, in which many of the
        parameterization features have been removed.</p>

      <p>The difference between the schema styles may be illustrated by considering this ODD
        specification: <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
          <elementSpec module="drama" ident="performance">
            <!-- ... -->
            <classes>
              <memberOf key="model.frontPart.drama"/>
            </classes>
            <content>
              <sequence>
                <alternate minOccurs="0" maxOccurs="unbounded">
                  <classRef key="model.divTop"/>
                  <classRef key="model.global"/>
                </alternate>
                <sequence minOccurs="1" maxOccurs="unbounded">
                  <classRef key="model.common"/>
                  <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence minOccurs="0" maxOccurs="unbounded">
                  <classRef key="model.divBottom"/>
                  <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
              </sequence>
            </content>
            <!-- ... -->
          </elementSpec>
        </egXML> A simple rendering to RELAX NG produces this:
        <eg xml:space="preserve"><![CDATA[performance =
 element performance { 
  (model.divTop | model.global)*,
  (model.common, model.global*)+,
  (model.divBottom, model.global*)*
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.global.linking.attribute.corresp,
  att.global.linking.attribute.synch,
  att.global.linking.attribute.sameAs,
  att.global.linking.attribute.copyOf,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.global.linking.attribute.exclude,
  att.global.linking.attribute.select
}]]></eg> In the above, a subsequent redefinition of the attribute class (such as <ident type="class"
          >att.global</ident>) would have no effect, since references to such classes have been
        expanded to reference their constituent attributes.</p>
      <p> The equivalent parameterized version might look like this:
        <eg xml:space="preserve"><![CDATA[performance =
  element performance { performance.content, performance.attributes }
performance.content =
  (model.divTop | model.global)*,
  (model.common, model.global*)+,
  (model.divBottom, model.global*)*
performance.attributes = att.global.attributes, empty]]></eg> Here, the attribute class <ident type="class">att.global</ident> is provided via an
        explicit reference (<code>att.global.attributes</code>), and can therefore be redefined.
        Moreover, the attributes are separated from the content model, allowing either to be
        overridden.</p>
      <p>In the remainder of these section, the terms <term>simple schema</term> and
          <term>parameterized schema</term> are used to distinguish the two schema types. An ODD
        processor is not required to support both, though the simple schema output is generally
        preferable for most applications.</p>

      <p>Thirdly, the problem of missing components must be resolved. For example, consider this
        (fictitious) model for <gi>sp</gi>: <egXML xmlns="http://www.tei-c.org/ns/Examples"
          xml:lang="und" source="#UND">
          <elementSpec ident="sp">
            <!-- ... -->
            <content>
	      <sequence minOccurs="1" maxOccurs="1">
		<classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
		<sequence minOccurs="0" maxOccurs="1">
                  <elementRef key="speaker"/>
                  <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
		</sequence>
	      </sequence>
            </content>
            <!-- ... -->
          </elementSpec>
        </egXML> This proposes anything from the class <ident type="class">model.global</ident>,
        followed optionally by a <gi>speaker</gi> element followed by anything from the <ident
          type="class">model.global</ident> class. What happens if <gi>speaker</gi> is removed from
        the schema? The following would result: <egXML xmlns="http://www.tei-c.org/ns/Examples"
          xml:lang="und" valid="false" source="#UND">
          <elementSpec ident="sp">
            <!-- ... -->
            <content>
	      <sequence minOccurs="1" maxOccurs="1">
		<classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
	      </sequence>
            </content>
            <!-- ... -->
          </elementSpec>
        </egXML> which is illegal in DTD and W3C schema languages, since for a given member of
          <ident type="class">model.global</ident> it is impossible to be sure which rule is being
        used. This situation is not detected when RELAX NG is used, since the language is able to
        cope with non-deterministic content models of this kind and does not require that only a
        single rule be used.</p>
	<!-- not sure if this works : needs testing : original source clearly wrong though -->

      <p>Finally, an application will need to have some method of associating the schema with
        document instances that use it. The TEI does not mandate any particular method of doing
        this, since different schema languages and processors vary considerably in their
        requirements. ODD processors may wish to build in support for some of the methods for
        associating a document instance with a schema. The TEI does not mandate any particular
        method, but does suggest that those which are already part of XML (the DOCTYPE declaration
        for DTDs) and W3C Schema (the <att>xsi:schemaLocation</att> attribute) be supported where
        possible.</p>

      <p>In order for the <att>xsi:schemaLocation</att> attribute to be valid when a document is
        validated against either a DTD or a RELAX NG schema, ODD processors may wish to add
        declarations for this attribute and its namespace to the root element, even though these are
        not part of the TEI <foreign>per se</foreign>. For DTDs this means adding <eg><![CDATA[xsi:schemaLocation CDATA #IMPLIED xmlns:xsi CDATA #FIXED
'http://www.w3.org/2001/XMLSchema-instance']]></eg> to the list of attributes on the root element,
        which permits the non-namespace-aware DTD language to recognize the
          <code>xsi:schemaLocation</code> notation. For RELAX NG, the namespace and attribute would
        be declared in the usual way: <eg><![CDATA[namespace xsi =
"http://www.w3.org/2001/XMLSchema-instance"]]></eg> and <eg><![CDATA[attribute
xsi:schemaLocation { list { teidata.namespace, teidata.pointer }+ }]]></eg> inside the root element
        declaration.</p>

      <p>Note that declaration of the <att>xsi:schemaLocation</att> attribute in a W3C Schema schema
        is not permitted. Therefore, if W3C Schemas are being generated by converting the RELAX NG
        schema (for example, with <name>trang</name>), it may be necessary to perform that
        conversion prior to adding the <att>xsi:schemaLocation</att> declaration to the RELAX
        NG.</p>

      <p>It is recognized that this is an unsatisfactory solution, but it permits users to take
        advantage of the W3C Schema facility for indicating a schema, while still permitting
        documents to be validated using DTD and RELAX NG processors without any conflict.</p>

    </div>

    <div xml:id="IM-naming">
      <head>Names and Documentation in Generated Schemas</head>
      <p>When processing class, element, or macro specifications, there are three general rules:
          <list rend="numbered">
          <item>If a RELAX NG pattern or DTD parameter entity is being created, its name is the
            value of the corresponding <att>ident</att> attribute, prefixed by the value of any
              <att>prefix</att> attribute on <gi>schemaSpec</gi>. This allows for elements from an
            external schema to be mixed in without risk of name clashes, since all TEI elements can
            be given a distinctive prefix such as <val>tei_</val>. Thus <egXML
              xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
              <schemaSpec ident="test" prefix="tei_">
                <elementSpec ident="sp">
                  <!--...-->
                </elementSpec>
              </schemaSpec>
            </egXML> may generate a RELAX NG (compact syntax) pattern like this:
            <eg><![CDATA[ tei_sp = element sp { ... }]]></eg> References to these patterns (or, in DTDs, parameter entities) also need to be prefixed
            with the same value. </item>

          <item>If an element or attribute is being created, its default name is the value of the
              <att>ident</att> attribute, but if there is an <gi>altIdent</gi> child, its content is
            used instead. </item>

          <item>Where appropriate, the documentation strings in <gi>gloss</gi> and <gi>desc</gi>
            should be copied into the generated schema. If there is only one occurrence of either of
            these elements, it should be used regardless, but if there are several, local processing
            rules will need to be applied. For example, if there are several with different values
            of <att>xml:lang</att>, a locale indication in the processing environment might be used
            to decide which to use. For example, <egXML source="#SELF"
              xmlns="http://www.tei-c.org/ns/Examples" xml:lang="mul">
              <elementSpec module="core" ident="head">
                <equiv/>
                <gloss>heading</gloss>
                <gloss xml:lang="fr">en-tÃªte</gloss>
                <gloss xml:lang="es">encabezamiento</gloss>
                <gloss xml:lang="it">titolo</gloss>
                <!-- ... -->
              </elementSpec>
            </egXML> might generate a RELAX NG schema fragment like the following, if the locale is
            determined to be French: <eg xml:space="preserve"><![CDATA[head =
  ## en-tÃªte
  element head { head.content, head.attributes }]]></eg>
          </item>
        </list> Alternatively, a selection might be made on the basis of the value of the
          <att>version</att> attribute which these elements carry as members of the <ident
          type="class">att.translatable</ident> class. </p>
      <p>In addition, there are three conventions about naming patterns relating to classes; ODD
        processors need not follow them, but those reading the schemas generated by the TEI project
        will find it necessary to understand them: <list rend="numbered">
          <item>when a pattern for an attribute class is created, it is named after the attribute
            class identifier (as above) suffixed by <code>.attributes</code> (e.g.
              <code>att.editLike.attributes</code>); </item>
          <item>when a pattern for an attribute is created, it is named after the attribute class
            identifier (as above) suffixed by <code>.attribute.</code> and then the identifier of
            the attribute (e.g. <code>att.editLike.attribute.resp</code>);</item>

          <!-- check this -->
          <item>when a parameterized schema is created, each element generates patterns for its
            attributes and its contents separately, suffixing respectively <code>.attributes</code>
            and <code>.contents</code> to the element name.</item>
        </list>
      </p>
    </div>

    <div xml:id="IMRN">
      <head>Making a RELAX NG Schema</head>

      <p>To create a RELAX NG schema, the processor processes every <gi>macroSpec</gi>,
          <gi>classSpec</gi>, and <gi>elementSpec</gi> in turn, creating a RELAX NG pattern for
        each, using the naming conventions listed above. The order of declaration is not important,
        and a processor may well sort them into alphabetical order of identifier.</p>

      <p>A complete RELAX NG schema must have an <gi>rng:start</gi> element defining which elements
        can occur as the root of a document. The ODD <gi>schemaSpec</gi> has an optional
          <att>start</att> attribute, containing one or more patterns, which can be used to
        construct the <gi>rng:start</gi>. A pattern normally corresponds to an element name, but if
        a prefix (see above, <ptr target="#IM-naming"/>) is supplied for an element, the pattern
        consists of the prefix name with the element name.</p>

      <div xml:id="IMMA">
        <head>Macros</head>
        <p>An ODD macro generates a corresponding RELAX NG pattern by processing the body of the
            <gi>content</gi> element in the same way as elsewhere. Thus <egXML
            xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
            <macroSpec module="tei" ident="macro.phraseSeq">
              <content>
                <alternate minOccurs="0" maxOccurs="unbounded">
                  <textNode/>
                  <classRef key="model.gLike"/>
                  <classRef key="model.phrase"/>
                  <classRef key="model.global"/>
                </alternate>
              </content>
            </macroSpec>
          </egXML> produces the following <egXML xmlns="http://www.tei-c.org/ns/Examples"
            xml:lang="und" source="#UND">
            <define xmlns="http://relaxng.org/ns/structure/1.0" name="macro.phraseSeq">
              <zeroOrMore>
                <choice>
                  <text/>
                  <ref name="model.gLike"/>
                  <ref name="model.phrase"/>
                  <ref name="model.global"/>
                </choice>
              </zeroOrMore>
            </define>
          </egXML>
          <!--Although some versions of these Guidelines show the RELAX NG output in the
          compact syntax, both the content of the <gi>content</gi> element and the unified ODD
          specification generated by the TEI ODD processing software always store RELAX NG in the
          more verbose XML syntax. However, the two formats are interchangeable.--></p>
      </div>

      <div xml:id="IMCL">
        <head>Classes</head>
        <p>An ODD model class always generates a RELAX NG pattern definition listing all the members
          of the class in alternation. For example <egXML xmlns="http://www.tei-c.org/ns/Examples"
            xml:lang="und" source="#UND">
            <classSpec module="tei" type="model" ident="model.measureLike">
              <!-- ... -->
            </classSpec>
          </egXML> will produce something like the following: <egXML
            xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
            <define xmlns="http://relaxng.org/ns/structure/1.0" name="model.measureLike">
              <choice>
                <ref name="num"/>
                <ref name="measure"/>
                <ref name="measureGrp"/>
              </choice>
            </define>
          </egXML> assuming that the elements <gi>num</gi>, <gi>measure</gi>, and
            <gi>measureGrp</gi> are all defined in the schema concerned as members of that class. A
          model declaration may also generate a number of other patterns corresponding with
          sequences or alternations of the class members: <!--Depending on the value of the <att>generate</att> attribute on the
            <gi>classSpec</gi>, it may also generate a set of sequences as well as alternation
          patterns. Thus we may also generate the <ident>sequence</ident>,
            <ident>sequenceOptional</ident>, <ident>sequenceRepeatable</ident>, and
            <ident>sequenceOptionalRepeatable</ident> patterns:-->
          <egXML xmlns="http://www.tei-c.org/ns/Examples" xml:lang="und" source="#UND">
            <define xmlns="http://relaxng.org/ns/structure/1.0" name="model.measureLike_sequence">
              <ref name="num"/>
              <ref name="measure"/>
              <ref name="measureGrp"/>
            </define>
            <define xmlns="http://relaxng.org/ns/structure/1.0"
              name="model.measureLike_sequenceOptional">
              <optional>
                <ref name="num"/>
              </optional>
              <optional>
                <ref name="measure"/>
              </optional>
              <optional>
                <ref name="measureGrp"/>
              </optional>
            </define>
            <define xmlns="http://relaxng.org/ns/structure/1.0"
              name="model.measureLike_sequenceOptionalRepeatable">
              <zeroOrMore>
                <ref name="num"/>
              </zeroOrMore>
              <zeroOrMore>
                <ref name="measure"/>
              </zeroOrMore>
              <zeroOrMore>
                <ref name="measureGrp"/>
              </zeroOrMore>
            </define>
            <define xmlns="http://relaxng.org/ns/structure/1.0"
              name="model.measureLike_sequenceRepeatable">
              <oneOrMore>
                <ref name="num"/>
              </oneOrMore>
              <oneOrMore>
                <ref name="measure"/>
              </oneOrMore>
              <oneOrMore>
                <ref name="measureGrp"/>
              </oneOrMore>
            </define>
          </egXML> where the pattern name is created by appending an underscore and the name of the
          generation type to the class name. </p>
        <p>When classes are referenced using the <gi>classRef</gi> element, it is possible to
          indicate which of the available patterns is required by means of the <att>expand</att>
          attribute. </p>
        <p>Attribute classes work by producing a pattern containing definitions of the appropriate
          attributes. So <egXML xmlns="http://www.tei-c.org/ns/Examples" source="#SELF">
            <classSpec module="verse" type="atts" ident="att.enjamb">
              <attList>
                <attDef ident="enjamb" usage="opt">
                  <equiv/>
                  <desc>indicates whether the end of a verse line is marked by enjambement.</desc>
                  <datatype>
                    <dataRef key="teidata.enumerated"/>
                  </datatype>
                  <valList type="open">
                    <valItem ident="no">
                      <equiv/>
                      <desc>the line is end-stopped </desc>
                    </valItem>
                    <valItem ident="yes">
                      <equiv/>
                      <desc>the line in question runs on into the next </desc>
                    </valItem>
                    <valItem ident="weak">
                      <equiv/>
                      <desc>the line is weakly enjambed </desc>
                    </valItem>
                    <valItem ident="strong">
                      <equiv/>
                      <desc>the line is strongly enjambed</desc>
                    </valItem>
                  </valList>
                </attDef>
              </attList>
            </classSpec>
          </egXML> produces <egXML xmlns="http://www.tei-c.org/ns/Examples" source="#NONE">
            <rng:define xmlns:rng="http://relaxng.org/ns/structure/1.0" name="att.enjamb.attributes">
              <rng:ref name="att.enjamb.attribute.enjamb"/>
              <rng:empty/>
            </rng:define>
            <rng:define xmlns:rng="http://relaxng.org/ns/structure/1.0"
              name="att.enjamb.attribute.enjamb">
              <rng:optional>
                <rng:attribute name="enjamb">
                  <a:documentation xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
                    >(enjambement) indicates whether the end of a verse line is marked by
                    enjambement. Sample values include: 1] no; 2] yes; 3] weak; 4]
                    strong</a:documentation>
                  <rng:ref name="teidata.enumerated"/>
                </rng:attribute>
              </rng:optional>
            </rng:define>
          </egXML> Since the processor may have expanded the attribute classes already, separate
          patterns are generated for each attribute in the class as well as one for the class
          itself. This allows an element to refer directly to a member of a class. Notice that the
            <gi>desc</gi> element is used to add an <gi>a:documentation</gi> element to the schema,
          which some editors use to provide help during composition. The <gi>desc</gi> elements in
          the <gi>valList</gi> are used to create the human-readable sentence <quote>Sample values
            include: 1] no; 2] yes; 3] weak; 4] strong</quote> Naturally, this behaviour is not
          mandatory; and other ODD processors may create documentation in other ways, or ignore
          those parts of the ODD specifications when creating schemas.</p>

        <p>An individual attribute consists of an <gi>rng:attribute</gi> with a <att>name</att>
          attribute derived according to the naming rules described above (<ptr target="#IM-naming"
          />). In addition, the ODD model supports a <gi>defaultVal</gi>, which is transformed to a
            <att scheme="RNGANN">defaultValue</att> attribute in the namespace <ident type="ns"
            >http://relaxng.org/ns/compatibility/annotations/1.0</ident> on the
            <gi>rng:attribute</gi>. The body of the attribute is taken from the <gi>datatype</gi>
          child, unless there is a supporting <gi>valList</gi> with a <att>type</att> value of
            <val>closed</val>. In that case an <gi>rng:choice</gi> is created, listing the allowed
          values. Thus the following attribute definition <egXML
            xmlns="http://www.tei-c.org/ns/Examples" source="#NONE">
            <attDef ident="full" usage="opt">
              <defaultVal>yes</defaultVal>
              <valList type="closed">
                <valItem ident="yes">
                  <desc>the name component is spelled out in full.</desc>
                </valItem>
                <valItem ident="abb">
                  <gloss>abbreviated</gloss>
                  <desc>the name component is given in an abbreviated form.</desc>
                </valItem>
                <valItem ident="init">
                  <gloss>initial letter</gloss>
                  <desc>the name component is indicated only by one initial.</desc>
                </valItem>
              </valList>
            </attDef>
          </egXML> may generate this RELAX NG code: <egXML xmlns="http://www.tei-c.org/ns/Examples"
            source="#NONE">
            <define xmlns="http://relaxng.org/ns/structure/1.0" name="att.full">
              <optional>
                <attribute xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" name="full"
                  a:defaultValue="yes">
                  <choice>
                    <value>yes</value>
                    <a:documentation> the name component is spelled out in full. </a:documentation>
                    <value>abb</value>
                    <a:documentation> the name component is given in an abbreviated form. </a:documentation>
                    <value>init</value>
                    <a:documentation> the name component is indicated only by one initial.
                    </a:documentation>
                  </choice>
                </attribute>
              </optional>
            </define>
          </egXML> Note the use of the <ident type="ns"
            >http://relaxng.org/ns/compatibility/annotations/1.0</ident> namespace to provide
          default values and documentation. </p>
      </div>

      <div xml:id="IMEL">
        <head>Elements</head>
        <p>An <gi>elementSpec</gi> produces a RELAX NG specification in two parts; firstly, it must
          generate an <gi>rng:define</gi> pattern by which other elements can refer to it, and then
          it must generate an <gi>rng:element</gi> with the content model and attributes. It may be
          convenient to make two separate patterns, one for the element's attributes and one for its
          content model.</p>
        <p>The content model is created by processing the TEI declarations found within the
            <gi>content</gi> element; ; the attributes are processed in the same way as those from
          attribute classes, described above.</p>
      </div>

    </div>


    <div xml:id="IM-makeDTD">
      <head>Making a DTD</head>
      <p>Generation of DTDs largely follows the same pattern as RELAX NG generation, with one
        important exceptionâ<hi>the order of declaration matters</hi>. A DTD may not refer to an
        entity which has not yet been declared. Since both macros and classes generate DTD parameter
        entities, the TEI Guidelines are constructed so that they can be declared in the right
        order. A processor must therefore work in the following order: <list rend="numbered">
          <item>declare all model classes which have a <att>predeclare</att> value of
              <val>true</val></item>
          <item>declare all macros which have a <att>predeclare</att> value of
            <val>true</val></item>
          <item>declare all other classes</item>
          <item>declare the modules (if DTD fragments are being constructed)</item>
          <item>declare any remaining macros</item>
          <item>declare the elements and their attributes</item>
        </list>
        <!-- The implementer who avoids careful study of this issue
will come to grief.--></p>
      <p>Let us consider a complete example, a simple element with no attributes of its own: <egXML
          xmlns="http://www.tei-c.org/ns/Examples" source="#NONE">
          <elementSpec module="namesdates" ident="faith">
            <desc>specifies the faith, religion, or belief set of a person.</desc>
            <classes>
              <memberOf key="model.persStateLike"/>
              <memberOf key="att.editLike"/>
              <memberOf key="att.datable"/>
            </classes>
            <content xmlns:rng="http://relaxng.org/ns/structure/1.0">
              <macroRef key="macro.phraseSeq"/>
            </content>
          </elementSpec>
        </egXML> If DTD fragments are being generated (for use as described in <ptr target="#STPE"
        />), this will result in the following:
        <eg xml:space="preserve"><![CDATA[<!ENTITY % faith 'INCLUDE' >
<![ %faith; [

<!--doc:specifies the faith,  religion, or belief set of a person. -->
<!ELEMENT %n.faith; %om.RR; %macro.phraseSeq;>
<!ATTLIST %n.faith; xmlns CDATA "http://www.tei-c.org/ns/1.0">
<!ATTLIST %n.faith;
 %att.global.attributes;
 %att.editLike.attributes;
 %att.datable.attributes; >
]]]]><![CDATA[>]]></eg> Here the whole stanza is contained in a marked section (for use as described in <ptr
          target="#STPEEX"/>), the element name is parameterized (see <ptr target="#STPEGI"/>), and
        the class attributes are entity references derived from the <gi>memberOf</gi> records in
          <gi>classes</gi>. Note the additional attribute which provides a default <att scheme="XML"
          >xmlns</att> declaration for the element; the effect of this is that if the document is
        processed by a DTD-aware XML processor, the namespace declaration will be present
        automatically without the document author even being aware of it.</p>

      <p>A simpler rendition for a flattened DTD generated from a customization will result in the
        following, with no containing marked section, and no parameterized name:
        <eg xml:space="preserve"><![CDATA[<!ELEMENT faith %macro.phraseSeq;>
<!ATTLIST faith xmlns CDATA "http://www.tei-c.org/ns/1.0">
<!ATTLIST faith
 %att.global.attribute.xmlspace;
 %att.global.attribute.xmlid;
 %att.global.attribute.n;
 %att.global.attribute.xmllang;
 %att.global.attribute.rend;
 %att.global.attribute.xmlbase;
 %att.global.linking.attribute.corresp;
 %att.global.linking.attribute.synch;
 %att.global.linking.attribute.sameAs;
 %att.global.linking.attribute.copyOf;
 %att.global.linking.attribute.next;
 %att.global.linking.attribute.prev;
 %att.global.linking.attribute.exclude;
 %att.global.linking.attribute.select;
 %att.editLike.attribute.cert;
 %att.editLike.attribute.resp;
 %att.editLike.attribute.evidence;
 %att.datable.w3c.attribute.period;
 %att.datable.w3c.attribute.when;
 %att.datable.w3c.attribute.notBefore;
 %att.datable.w3c.attribute.notAfter;
 %att.datable.w3c.attribute.from;
 %att.datable.w3c.attribute.to;>]]></eg> Here the attributes from classes have been expanded into individual entity references.</p>



    </div>

    <div xml:id="IMGD">
      <head>Generating Documentation</head>
      <p>In Donald Knuth's literate programming terminology (<ptr target="#KNUTH"/>), the previous
        sections have dealt with the <term>tangle</term> process; to generate documentation, we now
        turn to the <term>weave</term> process.</p>

      <p>An ODD customization may consist largely of general documentation and examples, requiring
        no ODD-specific processing. It will normally however also contain a <gi>schemaSpec</gi>
        element and possibly some <gi>specGrp</gi> fragments.</p>

      <p> The generated documentation may be of two forms. On the one hand, we may document the
        customization itself, that is, only those elements (etc.) which differ in their
        specification from that provided by the TEI reference documentation. Alternatively, we may
        generate reference documentation for the complete subset of the TEI which results from
        applying the customization. The TEI Roma tools take the latter approach, and operate on the
        result of the first stage processing described in <ptr target="#IM-unified"/>.</p>

      <p>Generating reference documentation for <gi>elementSpec</gi>, <gi>classSpec</gi>, and
          <gi>macroSpec</gi> elements is largely dependent on the design of the preferred output.
        Some applications may, for example, want to turn all names of objects into hyperlinks, show
        lists of class members, or present lists of attributes as tables, lists, or inline prose.
        Another technique implemented in these Guidelines is to show lists of potential
          <soCalled>parents</soCalled> for each element, by tracing which other elements have them
        as possible members of their content models.</p>
      <p>One model of display on a web page is shown in <ptr target="#ref-faith"/>, corresponding to
        the <gi>faith</gi> element shown in section <ptr target="#IM-makeDTD"/>.</p>
      <figure xml:id="ref-faith">
        <graphic url="Images/ref-faith.png" width="450px"/>
        <head>Example reference documentation for <gi>faith</gi></head>
      </figure>

    </div>

    <!-- not sure what was intended here -->

    <!--
<div>
<head>Validation tools for other processors</head>

</div>
-->

    <div xml:id="STPE">
      <head>Using TEI Parameterized Schema Fragments</head>
      <p>The TEI parameterized DTD and RELAX NG fragments make use of parameter entities and
        patterns for several purposes. In this section we describe their interface for the user. In
        general we recommend use of ODD instead of this technique, which has been retained only for
        compatability reasons.</p>

      <div type="div3" xml:id="STPED">
        <head>Selection of Modules</head>

        <p>Special-purpose parameter entities are used to specify which modules are to be combined
          into a TEI DTD. They take the form <val>TEI.xxxxx</val> where <code>xxxx</code> is the
          name of the module as given in table <ptr target="#tab-mods"/> in <ptr target="#STMA"/>.
          For example, the parameter entity <ident type="pe">TEI.linking</ident> is used to define
          whether or not to include the module <ident type="module">linking</ident>. All such
          parameter entities are declared by default with the value <val>IGNORE</val>: to select a
          module, therefore, the encoder declares the appropriate parameter entities with the value
            <val>INCLUDE</val>. </p>

        <p>For XML DTD fragments, note that some modules generate two DTD fragments: for example the
            <ident type="module">analysis</ident> module generates fragments called <ident
            type="frag">analysis-decl</ident> and <ident type="frag">analysis</ident>. This is
          because the declarations they contain are needed at different points in the creation of an
          XML DTD. </p>

        <p>The parameter entity named for the module is used as the keyword controlling a
          conditional marked section in the DTD fragment generated by the <ident type="module"
            >tei</ident> module. The declarations for each DTD fragment constituting the module are
          contained within such marked sections. For example, the parameter entity <ident type="pe"
            >TEI.linking</ident> appears twice in <ident type="file">tei.dtd</ident>, once for the
            <ident type="frag">linking-decl</ident> schema fragment:
          <eg xml:space="preserve"><![CDATA[<!ENTITY % TEI.linking 'IGNORE' >
<![%TEI.linking;[
<!ENTITY % file.linking-decl PUBLIC '-//TEI P5//ENTITIES Linking, Segmentation, and Alignment//EN' 'linking-decl.dtd' >
%file.linking-decl;
]] >]]></eg> and once for the <ident type="frag">linking</ident> schema fragment:
          <eg xml:space="preserve"><![CDATA[<![%TEI.linking;[
<!ENTITY % file.linking PUBLIC '-//TEI P5//ELEMENTS Linking, Segmentation, and Alignment//EN' 'linking.dtd' >
%file.linking;]] >]]></eg> If TEI.linking has its default value of IGNORE, neither declaration has any effect. If
          however it has the value INCLUDE, then the content of each marked section is acted upon:
          the parameter entities <ident type="pe">file.linking</ident> and <ident type="pe"
            >file.linking-decl</ident> are referenced, which has the effect of embedding the content
          of the files they represent at the appropriate point in the DTD. </p>

        <p>The RELAX NG schema fragments can be combined in a wrapper schema using the standard
          mechanism of <gi>rng:include</gi> in that language.</p>

      </div>


      <div type="div3" xml:id="STPEEX">
        <head>Inclusion and Exclusion of Elements</head>

        <p>The TEI DTD fragments also use marked sections and parameter entity references to allow
          users to exclude the definitions of individual elements, in order either to make the
          elements illegal in a document or to allow the element to be redefined. The parameter
          entities used for this purpose have exactly the same name as the generic identifier of the
          element concerned. The default definition for these parameter entities is
            <val>INCLUDE</val> but they may be changed to <val>IGNORE</val> in order to exclude the
          standard element and attribute definition list declarations from the DTD. </p>

        <p>The declarations for the element <gi>p</gi>, for example, are preceded by a definition
          for a parameter entity with the name <ident rend="noindex" type="ge">p</ident> and
          contained within a marked section whose keyword is given as <code>%p;</code>: <eg xml:space="preserve"><![CDATA[<!ENTITY % p 'INCLUDE' >
<![ %p; [
       <!-- element and attribute list declaration for p here -->
]]]]></eg></p>
        <p>These parameter entities are defined immediately preceding the element whose declarations
          they control; because their names are completely regular, they are not documented further. </p>
        <p>To define a DTD in which the element <gi>p</gi> is excluded therefore, the entity <ident
            rend="noindex" type="pe">p</ident> needs to be redefined as <val>IGNORE</val> by
          ensuring that a declaration such as
          <eg xml:space="preserve"><![CDATA[<!ENTITY % p 'IGNORE' >]]></eg> is added earlier in the
          DTD than the default (see further <ptr target="#STOVLO"/>). </p>

        <p>Similarly, in the parameterized RELAX NG schemas, every element is defined by a pattern
          named after the element. To undefine an element therefore all that is necessary is to add
          a declaration like the following:
          <eg xml:space="preserve"><![CDATA[ p = notAllowed ]]></eg>
        </p>
      </div>

      <div type="div3" xml:id="STPEGI">
        <head>Changing the Names of Generic Identifiers</head>

        <p>In the TEI DTD fragments, elements are not referred to directly by their generic
          identifiers; instead, the DTD fragments refer to parameter entities which expand to the
          standard generic identifiers. This allows users to rename elements by redefining the
          appropriate parameter entity. Parameter entities used for this purpose are formed by
          taking the standard generic identifier of the element and attaching the string
            <val>n.</val> as a prefix. Thus the standard generic identifiers for paragraphs, notes,
          and quotations, <gi>p</gi>, <gi>note</gi>, and <gi>persName</gi> are defined by
          declarations of the following form: <eg xml:space="preserve"><![CDATA[<!ENTITY % n.p "p">
<!ENTITY % n.note "note"> 
<!ENTITY % n.persName "persName">]]></eg> Note that since all names are case-sensitive, the specific
          mix of uppercase and lowercase letters in the standard generic identifier must be
          preserved in the entity name. </p>

        <p>These declarations are generated by an ODD processor when TEI DTD fragments are created. </p>

        <p> In the RELAX NG schemas, all elements are normally defined using a pattern with the same
          name as the element (as described in <ptr target="#IM-naming"/>): for example
          <eg xml:space="preserve"><![CDATA[abbr = element abbr { abbr.content, abbr.attributes }]]></eg> The easiest way of renaming the element is thus simply to rewrite the pattern with a
          different element name; any references use the pattern, not the element, name.
          <eg xml:space="preserve"><![CDATA[abbr = element abbrev { abbr.content, abbr.attributes }]]></eg> More complex revisions, such as redefining the content of the element (defined by the
          pattern <ident type="rng">abbr.content</ident>) or its attributes (defined by the pattern
            <ident type="rng">abbr.attributes</ident>) can be accomplished in a similar way, using
          the features of the RELAX NG language. The recommended method of carrying out such
          modifications is however to use the ODD language as further described in section <ptr
            target="#TD"/>.</p>
      </div>


      <div type="div3" xml:id="STOVLO">
        <head>Embedding Local Modifications (DTD only)</head>

        <p>Any local modifications to a DTD (i.e. changes to a schema other than simple inclusion or
          exclusion of modules) are made by declarations stored in one of two local extension files,
          one containing modifications to the TEI parameter entities, and the other new or changed
          declarations of elements and their attributes. Entity declarations must be made which
          associate the names of these two files with the appropriate parameter entity so that the
          declarations they contain can be embedded within the TEI DTD at an appropriate point.</p>

        <p>The following entities are referred to by the main <ident type="file">tei.dtd</ident>
          file to embed portions of the TEI DTD fragments or locally developed extensions. <list
            type="gloss">
            <label><ident type="pe">TEI.extensions.ent</ident></label>
            <item>identifies a local file containing extensions to the TEI parameter entities</item>
            <label><ident type="pe">TEI.extensions.dtd</ident></label>
            <item>identifies a local file containing extensions to the TEI module</item>
          </list></p>
        <p>For example, if the relevant files are called <ident rend="noindex" type="file"
            >project.ent</ident> and <ident rend="noindex" type="file">project.dtd</ident>, then
          declarations like the following would be appropriate: <eg xml:space="preserve"><![CDATA[<!ENTITY % TEI.extensions.ent SYSTEM 'project.ent' >
<!ENTITY % TEI.extensions.dtd SYSTEM 'project.dtd' >]]></eg></p>

        <p>When an entity is declared more than once, the first declaration is binding and the
          others are ignored. The local modifications to parameter entities should therefore be
          handled before the standard parameter entities themselves are declared in <ident
            type="file">tei.dtd</ident>. The entity <ident type="pe">TEI.extensions.ent</ident> is
          referred to before any TEI declarations are handled, to allow the user's declarations to
          take priority. If the user does not provide a <ident type="pe">TEI.extensions.ent</ident>
          entity, the entity will be expanded to the empty string.</p>
        <p>For example the encoder might wish to add two phrase-level elements <gi
            scheme="imaginary">it</gi> and <gi scheme="imaginary">bd</gi>, perhaps as synonyms for
            <tag>hi rend='italics'</tag> and <tag>hi rend='bold'</tag>. As described in chapter <ptr
            target="#MD"/>, this involves two distinct steps: one to define the new elements, and
          the other to ensure that they are placed into the TEI document structure at the right
          place. </p>
        <p>Creating the new declarations is done in the same way for user-defined elements as for
          any other; the same parameter entities need to be defined so that they may be referenced
          by other elements. The content models of these new elements may also reference other
          parameter entities, which is why they need to be declared after other declarations. </p>
        <p>The second step involves modifying the element class to which the new elements should be
          attached. This requires that the parameter entity <ident type="pe">macro.phraseSeq</ident>
          should be modified to include the generic identifiers for the new elements we wish to
          create. The declaration for each modifiable parameter entity in the DTD includes a
          reference to an additional parameter entity with the same name prefixed by an
            <code>x.</code>; these entities are declared by default as the null string. However, in
          the file containing local declarations they may be redeclared to include references to the
          new class members: <eg><![CDATA[<!ENTITY % x.macro.phraseSeq 'it | bd
|'>]]></eg> and this declaration will take precedence over the default when the declaration for
          macro.phraseSeq is evaluated. </p>
      </div>

    </div>

  </div>

</div>
